#!/bin/bash
# shellcheck disable=SC1091

source "$HOME/.dotfiles/assets/shell/shell-utils-sh"

eval "$HIDE_NOTIFICATIONS"

OUT_DIR="/tmp/00_Compressed"
ensure_dir "$OUT_DIR" >/dev/null

notify() { notify-send -t 1200 -e -a lf -i "${ICON:-ark}" "lf" "$1"; }
called_from_lf() { [ -n "$LF_LEVEL" ]; }

[ $# -eq 0 ] && exit 0

FILES=("$@")

# Determinar si los archivos provienen de directorios diferentes
#-------------------------------------------------------------------------------

DIRS=$(for f in "$@"; do dirname "$f"; done | sort -u)
NUM_DIRS=$(echo "$DIRS" | wc -l)

if [ "$NUM_DIRS" -eq 1 ]; then
	# Si todos los archivos vienen del mismo directorio, usamos el nombre
	# del directorio para el archivo comprimido.
	BASE_NAME=$(basename "$DIRS")
	COMMON_PATH=$(dirname "$1")
else
	# Si están en directorios distintos, por el nombre del comprimido
	BASE_NAME=$(
		whiptail --title "Nombre del archivo" \
			--inputbox "Ingrese el nombre del archivo comprimido:" 10 60 3>&1 1>&2 2>&3
	)
	[ -z "$BASE_NAME" ] && exit 0

	# Obtenemos la ruta común para todos los archivos, necesitamos comprimir
	# desde $COMMON_PATH usando rutas relativas para evitar subdirectorios
	# innecesarios dentro de nuestro archivo comprimido

	# Inicializamos la ruta común con el directorio del primer archivo
	COMMON_PATH=$(dirname "${FILES[0]}")

	# Recorremos los demás archivos
	for f in "${FILES[@]:1}"; do
		DIR=$(dirname "$f")
		# Mientras la ruta común no sea un prefijo de DIR, subimos un nivel
		while [[ "$DIR" != "$COMMON_PATH"* ]]; do
			COMMON_PATH=$(dirname "$COMMON_PATH")
		done
	done
fi

#-------------------------------------------------------------------------------

# Construimos una lista con los archivos a comprimir para que el usuario
# pueda verificar que todo está correcto
if [ "$(printf "%s\n" "$@" | wc -l)" -lt 3 ]; then
	# shellcheck disable=SC2124
	LIST="$@"
else
	LIST="$(printf "%s\n" "$@" | head -n1)\n"
	LIST+="$(printf "%s\n" "$@" | tail -n1)"
fi

# Mostramos los archivos a comprimir
whiptail \
	--title "Archivos seleccionados" \
	--yesno "$LIST\nComprimir en: $OUT_DIR/${BASE_NAME}.*" 10 60 || exit

# Preguntamos en que formato quiere comprimir los archivos
FORMAT=$(
	whiptail \
		--title "Formato" --menu "Elige el formato del comprimido" 10 60 3 \
		"tar" "" "zip" "" "7z" "" 3>&1 1>&2 2>&3
)

#-------------------------------------------------------------------------------

REL_FILES=()
for f in "$@"; do
	REL_FILES+=("$(realpath --relative-to="$COMMON_PATH" "$f")")
done

case "$FORMAT" in
tar)
	OUT_FILE="$OUT_DIR/${BASE_NAME}.tar.gz"
	tar -zcvf "$OUT_FILE" -C "$COMMON_PATH" "${REL_FILES[@]}"
	;;
7z)
	OUT_FILE="$OUT_DIR/${BASE_NAME}.7z"
	(cd "$COMMON_PATH" && 7z a "$OUT_FILE" "${REL_FILES[@]}")
	;;
zip)
	OUT_FILE="$OUT_DIR/${BASE_NAME}.zip"
	(cd "$COMMON_PATH" && zip -r "$OUT_FILE" "${REL_FILES[@]}")
	;;
esac &>/dev/null

if ! called_from_lf; then
	echo "$OUT_FILE"
	exit
fi

#-------------------------------------------------------------------------------

if [ -f "$OUT_FILE" ]; then
	notify "Archivo comprimido en\n<i>$OUT_DIR</i>"
else
	ICON=system-error notify "Hubo un error al comprimir los archivos"
	exit 1
fi

[ -z "$LF_ID" ] && exit

for file in "${FILES[@]}"; do
	lf -remote "send $LF_ID unselect \"$file\""
done

lf -remote "send $LF_ID select \"$OUT_FILE\""
lf -remote "send $LF_ID reload"
lf -remote "send $LF_ID clear"

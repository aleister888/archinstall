#  _  __                    __ _
# | |/ _|   ___ ___  _ __  / _(_) __ _
# | | |_   / __/ _ \| '_ \| |_| |/ _` |
# | |  _| | (_| (_) | | | |  _| | (_| |
# |_|_|    \___\___/|_| |_|_| |_|\__, |
#                                |___/

############
# Opciones #
############

set shell bash
set shellopts '-eu'
set ifs "\n"
set scrolloff 10
set icons
set relativenumber
set info size:time
set ratios 3:5:4
set autoquit true
set hiddenfiles ".*:*.aux:*.toc:*.sty:*.out:*.log:*.bbl:*.blg:*.synctex.gz:_minted:*.bcf:*.nav:*.run.xml:*.snm:*.xwm:*.lrc:*-autosave.kra:*~"

set cleaner '~/.config/lf/cleaner'
set previewer '~/.config/lf/scope'

######################
# Comandos/Funciones #
######################

cmd home :cd ~/
cmd mkdir $mkdir -p "$(echo $* | tr ' ' '\ ')"

# Limpiar todas las selecciones
cmd clear_selection ${{
	lf -remote "send $id clear"
	lf -remote "send $id glob-unselect *"
	lf -remote "send $id reload"
	clear
}}

cmd myclear ${{
	lf -remote "send $id reload"
	clear
}}

# Abrir archivos en función del tipo
cmd open ${{
	FILETYPE="$(xdg-mime query filetype "$(readlink -f $f)")"
	{
	case $FILETYPE in
		*/x-7z-compressed | */vnd.rar | */*-tar | */zip | */gzip)
			setsid -f xarchiver "$fx" ;;

		*/vnd.*document*)
			setsid -f libreoffice "$fx" ;;

		*/pdf | */epub* | */vnd.comicbook*)
			zathura "$f" ;;

		text/* | */xml | */json | inode/x-empty | */x-shellscript | */x-desktop | */yaml | */sql | */x-php)
			$EDITOR "$fx" ;;

		image/x-eps)
			HASH="$(stat --printf '%n\0%i\0%F\0%s\0%W\0%Y' -- "$(readlink -f "$f")" | sha256sum | awk '{print $1}')"
			CACHE="${XDG_CACHE_HOME:-$HOME/.cache}/lf/thumb.$HASH"
			[ ! -f "$CACHE.jpg" ] && \
				gs -dSAFER -dBATCH -dNOPAUSE -sDEVICE=jpeg -r300 -dEPSCrop \
					-sOutputFile="$CACHE.jpg" "$f"
			nsxiv "$CACHE.jpg"
			;;

		image/*)
			DIR="$(dirname -- "$f")"
			BASE="$(basename -- "$f")"

			# Listar imágenes en el directorio (ordenadas alfabéticamente)
			IMAGES=$(printf '%s\n' "$DIR"/*.{jpg,jpeg,png,gif,bmp,tiff,ppm,svg,webp,xpm} |
				grep -iE '\.(jpg|jpeg|png|gif|bmp|tiff|ppm|svg|webp|xpm)$' |
				sort -f)

			# Rotar la lista para que empiece en $BASE
			ROTATED=$(printf '%s\n' "$IMAGES" | awk -v start="$DIR/$BASE" '
				BEGIN { hit = 0 }
				$0 == start { hit = 1; print; next }
				{ if (hit) print; else buf = buf $0 ORS }
				END { if (buf != "") printf "%s", buf }
			')

			# Pasar a nsxiv
			printf '%s\n' "$ROTATED" |
				nsxiv -aio |
				while read -r FILE; do
					[ -z "$FILE" ] && continue
					lf -remote "send select \"$FILE\""
					lf -remote "send toggle"
				done &
			;;

		audio/*)
			mpv --audio-display=no "$f" ;;

		video/*)
			mpv "$f" ;;

		*/x-keepass2)
			setsid -f keepassxc "$f" ;;

		*/x-reaper-*)
			setsid -f reaper "$f" ;;

		*/x-tuxguitar | */gpx+xml | */x-gnuplot | */x-gtp)
			setsid -f tuxguitar "$fx" ;;

		# Si no tenemos configurada una forma de abrirlo, usamos xdg-open
		*) for f in $fx; do setsid -f $OPENER $f; done ;;
	esac
	} 2>/dev/null
}}

# Muestra información sobre el directorio actual
cmd on-cd &{{
	# Mostrar el directorio en el nombre de la ventana
	printf '\033]0;%s\007' "$(pwd | sed "s|^$HOME|~|")" > /dev/tty
	# Mostrar información sobre los repositorios (Rama y URL)
	if [ -d .git ] || [ -f .git ]; then
		branch="$(git branch --show-current 2>/dev/null)" || true
		remote="$(git config --get "branch.$branch.remote" 2>/dev/null)" || true
		url="$(git remote get-url "$remote" 2>/dev/null)" || true
		fmt="\033[32;1m%u@%h\033[0m:\033[34;1m%w\033[0m\033[33;1m [$branch >> $url]\033[0m"
	else
		fmt="\033[32;1m%u@%h\033[0m:\033[34;1m%d\033[0m\033[1m%f\033[0m"
	fi
	lf -remote "send $id set promptfmt \"$fmt\""
}}

# Muestra información del archivo seleccionado con eza
cmd on-select &{{
	INFO="[$(/usr/bin/du -chs $fx | grep total | awk '{print $1}')"
	TOTAL_BYTES="$(stat -c %s "$fx")"
	if [ ! -d "$fx" ] && [ "$TOTAL_BYTES" -le 4096 ]; then
		INFO+=":${TOTAL_BYTES}B] "
	else
		INFO+="] "
	fi
	# Añadimos los permisos, dueño, fecha y nombre
	INFO+=$(
		eza -dlo --color=always --time-style iso "$(basename "$f")" |
			awk '{printf "%s %s %s %s %s %s", $1, $4, $5, $6, $7, $8; for (i=9; i<=NF; i++) printf " %s", $i; print ""}' |
			sed 's/\\/\\\\/g;s/"/\\"/g'
	)
	lf -remote "send $id set statfmt \"$INFO\""
}}

# Comprimir archivos dentro de un directorio en el formato seleccionado
cmd compress ${{
	makoctl dismiss -a
	OUT_DIR="/tmp/00_Compressed"
	[ ! -e "$OUT_DIR" ] && mkdir -p "$OUT_DIR"

	# Convertir $fx en argumentos para los comandos de compresión
	set -- $fx
	# Si no hay archivos seleccionados, salir
	[ $# -eq 0 ] && exit 0

	# Determinar si los archivos provienen de directorios diferentes
	DIRS=$(dirname -z "$@" | tr '\0' '\n' | sort -u)
	NUM_DIRS=$(echo "$DIRS" | wc -l)

	if [ "$NUM_DIRS" -eq 1 ]; then
		# Si todos los archivos vienen del mismo directorio, usamos el nombre
		# del directorio para el archivo comprimido.
		BASE_NAME=$(basename "$DIRS")
	else
		# Archivos de diferentes directorios, preguntar al usuario por el nombre
		BASE_NAME=$(
			whiptail --title "Nombre del archivo" \
				--inputbox "Ingrese el nombre del archivo comprimido:" 10 60 3>&1 1>&2 2>&3
		)
		# Si el usuario cancela, salir
		[ -z "$BASE_NAME" ] && exit 0
	fi

	if [ "$(printf "%s\n" "$@" | wc -l)" -eq 1 ]; then
		LIST="$@"
	else
		LIST="$(printf "%s\n" "$@" | head -n1)\n...\n$(printf "%s\n" "$@" | tail -n1)"
	fi
	whiptail \
		--title "Archivos seleccionados" \
		--yesno "$LIST\nComprimir en: $OUT_DIR/${BASE_NAME}.*" 10 60 ||
	exit 0

	FORMATO=$(
		whiptail \
			--title "Formato" \
			--menu "¿En qué formato desea comprimirlos?" \
			10 60 3 \
			"tar" "" \
			"zip" "" \
			"7z" "" \
			3>&1 1>&2 2>&3
	)

	case "$FORMATO" in
		tar)
			ARCHIVO="$OUT_DIR/${BASE_NAME}.tar.gz"
			tar -zcvf "$ARCHIVO" "$@"
			;;

		7z)
			ARCHIVO="$OUT_DIR/${BASE_NAME}.7z"
			7z a "$ARCHIVO" "$@"
			;;

		zip)
			if ! whiptail \
				--title "Fragmentación" \
				--yesno "¿Desea fragmentar el archivo zip?" 10 60
			then
				ARCHIVO="$OUT_DIR/${BASE_NAME}.zip"
				zip -r "$ARCHIVO" "$@" &&
					notify-send -i ark "lf" "Archivo comprimido en\n<i>$OUT_DIR</i>"
				exit 0
			fi

			OPCION=$(
				whiptail \
					--title "Tamaño" \
					--menu "Seleccione tamaño de fragmento:" \
					10 70 3 \
					"10mb" "Discord" \
					"500mb" "Archivos grandes" \
					"gb" "Número personalizado de GB [1:Tamaño/2]" \
					3>&1 1>&2 2>&3
			)

			# Calcular tamaño total en bytes de todos los archivos seleccionados
			TOTAL_BYTES=$(/usr/bin/du -cb "$@" | grep total | awk '{print $1}')
			TOTAL_KB=$((TOTAL_BYTES / 1024))
			TOTAL_MB=$((TOTAL_KB / 1024))
			if [ "$TOTAL_MB" -le 1 ]; then
				SHOW_SIZE="${TOTAL_KB}kb"
			else
				SHOW_SIZE="${TOTAL_MB}mb"
			fi
			case "$OPCION" in
				"10mb")
					# Si la selección ocupa menos de 10mb, salimos
					# (podemos comprimir el archivo en un solo .zip)
					if [ "$TOTAL_MB" -lt 10 ]; then
						whiptail --title "Error" \
							--msgbox "Los archivos seleccionados son demasiado pequeños para fragmentar en 10mb. [$SHOW_SIZE]" 10 60
						exit 1
					fi
					SIZE="10m"
					;;
				"500mb")
					# Si la selección ocupa menos de 500mb, salimos
					# (podemos comprimir el archivo en un solo .zip)
					if [ "$TOTAL_MB" -lt 500 ]; then
						whiptail --title "Error" \
							--msgbox "Los archivos seleccionados son demasiado pequeños para fragmentar en 500mb. [$SHOW_SIZE]" 10 60
						exit 1
					fi
					SIZE="500m"
					;;

				"gb")
					MAX_SIZE=$((TOTAL_MB / 1024 / 2))

					if [ "$MAX_SIZE" -lt 1 ]; then
						whiptail --title "Error" \
							--msgbox "Los archivos seleccionados son demasiado pequeños para fragmentar en GB." 10 60
						exit 1
					fi

					while true; do
						SIZE_GB=$(
							whiptail \
								--inputbox "Ingrese el tamaño en GB (1-$MAX_SIZE):" \
								10 60 1 \
								3>&1 1>&2 2>&3
						)

						if ! [[ "$SIZE_GB" =~ ^[0-9]+$ ]]; then
							whiptail --title "Error" \
								--msgbox "Debe ingresar un número entero." 10 60
							continue
						fi

						if [ "$SIZE_GB" -lt 1 ] || [ "$SIZE_GB" -gt "$MAX_SIZE" ]; then
							whiptail --title "Error" \
								--msgbox "El valor debe estar entre 1 y $MAX_SIZE GB." 10 60
							continue
						fi

						SIZE="${SIZE_GB}g"
						break
					done
					;;
			esac

			# Si el archivo está fragmentado, lo guardamos en su propia carpeta
			OUT_DIR="/tmp/00_Compressed/${BASE_NAME}"
			[ ! -e "$OUT_DIR" ] && mkdir -p "$OUT_DIR"
			ARCHIVO="$OUT_DIR/${BASE_NAME}.zip"
			zip -r -s "$SIZE" "$ARCHIVO" "$@"
			;;
	esac

	[ -e "$ARCHIVO" ] &&
		notify-send -i ark "lf" "Archivo comprimido en\n<i>$OUT_DIR</i>"

	lf -remote "send $id reload"
	lf -remote "send $id select \"$ARCHIVO\""
}}

# Función para abrir un scratchpad en el directorio actual
cmd cdterm &{{
	cd "$(dirname $f)"; eval "setsid -f $TERMINAL $TERMTITLE scratchpad"
}}

# Enviar una notificación con el tamaño del ítem seleccionado
cmd size &{{
	makoctl dismiss -a
	notify-send -i system-file-manager \
		"El tamaño es de $(/usr/bin/du -chs $fx | grep total | awk '{print $1}')"
}}

# Renombrar los contenido del directorio actual con nvim
cmd bulk-rename ${{
	old="$(mktemp)"
	new="$(mktemp)"
	if [ -n "$fs" ]; then
		fs="$(basename $fs)"
	else
		fs="$(ls)"
	fi
	printf '%s\n' "$fs" >"$old"
	printf '%s\n' "$fs" >"$new"
	$EDITOR "$new"
	[ "$(wc -l < "$new")" -ne "$(wc -l < "$old")" ] && exit
	paste "$old" "$new" | while IFS= read -r names; do
		src="$(printf '%s' "$names" | cut -f1)"
		dst="$(printf '%s' "$names" | cut -f2)"
		if [ "$src" = "$dst" ] || [ -e "$dst" ]; then
			continue
		fi
		mv -- "$src" "$dst"
	done
	rm -- "$old" "$new"
	/usr/bin/lf -remote "send $id unselect"
}}

# Buscar con fzf cadenas entre los archivos
cmd fzf_grep ${{
	cmd="rg --column --line-number --no-heading --color=always --smart-case"
	fzf --ansi --disabled --layout=reverse --delimiter=: \
		--bind="start:reload([ -n {q} ] && $cmd -- {q} || true)" \
		--bind="change:reload([ -n {q} ] && $cmd -- {q} || true)" \
		--bind='enter:become(lf -remote "send $id select \"$(printf "%s" {1} | sed '\''s/\\/\\\\/g;s/"/\\"/g'\'')\"")' \
		--preview='bat --color=always --highlight-line={2} -- {1}'
}}

# Elegir archivo con fzf
cmd fzf_search ${{
	res="$(find . | fzf --reverse --header='Ir a la localización')"
	if [ -n "$res" ]; then
		if [ -d "$res" ]; then
			cmd="cd"
		else
			cmd="select"
		fi
		res="$(printf '%s' "$res" | sed 's/\\/\\\\/g;s/"/\\"/g')"
		/usr/bin/lf -remote "send $id $cmd \"$res\""
	fi
	lf -remote "send $id reload"
}}

# Extraer archivo
cmd extract ${{
	makoctl dismiss -a
	whiptail --title "¿Extraer archivo(s)?" \
	--yesno "¿Quieres extraer el archivo $f?" 10 60 && \
	{
		case "$(xdg-mime query filetype "$f")" in
		*/x-zstd-compressed-tar)
			unzstd "$f"
			aunpack "$(basename -s .zst "$f")"
			rm "$(basename -s .zst "$f")"
			;;
		# Extraemos archivos con 7z para poder extraer archivos .zip fragmentados
		*/zip)
			OUT_DIR="${f%.zip}"
			mkdir -p "$OUT_DIR"
			7z x "$f" -o"$OUT_DIR"
			;;
		*) aunpack $f ;;
		esac
	} && \
	notify-send -i ark "lf" "Extraído:\n<i>$(basename $f)</i>"
}}

# Pegar archivos copiados/cortados
cmd paste &{{
	makoctl dismiss -a
	set -- $(cat ~/.local/share/lf/files)
	mode="$1"
	shift
	case "$mode" in
		copy)
			rsync -av --ignore-existing --progress -- "$@" . |
			stdbuf -i0 -o0 -e0 tr '\r' '\n' |
			while IFS= read -r line; do
				/usr/bin/lf -remote "send $id echo $line"
			done &&
				notify-send -i copyq \
					"lf" \
					"Archivo(s) copiados."
			;;
		move)
			mv -n -- "$@" . &&
				notify-send -i copyq \
				"lf" \
				"Archivo(s) movidos."
		;;
	esac
	rm ~/.local/share/lf/files
}}

# Mover a la papelera
cmd trash ${{
	makoctl dismiss -a
	clear
	tput bold
	set -f
	printf "%s\n\n" "$fx"
	printf "¿Mover archivo(s) a la papelera? [s/N] "
	read ans
	[ $ans = "s" ] && trash-put $fx &&
	notify-send -i user-trash "lf" "Archivo(s) movido(s) a la papelera"
	lf -remote "send $id reload"
}}

# Vaciar la papelera
cmd clean-trash ${{
	makoctl dismiss -a
	clear
	tput bold
	set -f
	printf "Contenidos de la papelera:\n"
	trash-list
	printf "¿Vaciar papelera? [s/N] "
	read ans
	if [ $ans = "s" ] || [ $ans = "S" ]; then
		trash-empty -f && \
		notify-send -i user-trash "lf" "Archivo(s) borrados"
	fi
	lf -remote "send $id reload"
}}

# Restaurar archivos de la papelera
cmd restore-trash ${{
	makoctl dismiss -a
	TRASH_CONTENTS=$(trash-list)
	if [ -z "$TRASH_CONTENTS" ]; then
		notify-send -i system-error "lf" "La papelera esta vacía"
		exit 0
	fi

	clear
	tput bold
	set -f
	echo $TRASH_CONTENTS | sed "s|$HOME|~|"
	printf "¿Restaurar? [s/N] "
	read ans
	[ $ans = "s" ]
	if [ $ans = "s" ] || [ $ans = "S" ]; then
		trash-restore
		notify-send -i user-trash "lf" "Archivo(s) restaurado(s)"
	fi
	lf -remote "send $id reload"
}}

on-cd

##########
# Atajos #
##########

# Limpiar selección
map <backspace2> clear_selection

# Limpiar pantalla
map R myclear
# Recargar configuración
map C &lf -remote "send $id source ~/.config/lf/lfrc"

# Pegar archivos
map p paste

# Renombrar archivos
map r rename
map <c-r> bulk-rename

# Gestionar papelera
map S trash
map D clean-trash
map F restore-trash

# Abrir scratchpad en el directorio actual
map s cdterm

# Cambiar de directorio
map <esc> home
map z home
map t cd /tmp
map T cd /run/media

# Buscar archivo
map / :fzf_search
map <c-_> :fzf_grep

# Extraer/comprimir archivos
map E extract
map <c-e> compress

# Mostrar/ocultar los archivos ocultos
map h set hidden!

# Abrir/crear archivo con vim
map V push :!nvim<space>$f


# Abrir archivos
cmd open-with %export ; "$@" "$fx"
map <enter> push :open-with<space>

# Permitir arrastrar archivos hacia otra ventana
map <c-z> $setsid -f dragon-drop -a -x $fx

# Notificar del tamaño de los ítemes actuales
map P size

# Crear directorio
map m push %mkdir<space>

# Copiar el directorio del archivo actual al portapapeles
map Y ${{
	makoctl dismiss -a
	printf '"%s"' "$(dirname "$fx")" | wl-copy
	notify-send -i gpaste "lf" "Ruta copiada al portapapeles"
}}

# Salir del programa
map q ${{
	# Restaurar el título original de la ventana
	printf '\033]0;\007'
	/usr/bin/lf -remote "send $id quit"
}}

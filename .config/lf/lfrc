#  _  __                    __ _
# | |/ _|   ___ ___  _ __  / _(_) __ _
# | | |_   / __/ _ \| '_ \| |_| |/ _` |
# | |  _| | (_| (_) | | | |  _| | (_| |
# |_|_|    \___\___/|_| |_|_| |_|\__, |
#                                |___/

############
# Opciones #
############

set shell bash
set shellopts '-eu'
set ifs "\n"
set scrolloff 10
set icons
set relativenumber
set info size:time
set ratios 3:5:4
set autoquit true
set hiddenfiles ".*:*.aux:*.toc:*.sty:*.out:*.log:*.bbl:*.blg:*.synctex.gz:_minted:*.bcf:*.nav:*.run.xml:*.snm:*.xwm:*.lrc:*-autosave.kra:*~"

set cleaner '~/.config/lf/cleaner'
set previewer '~/.config/lf/scope'

######################
# Comandos/Funciones #
######################

cmd home :cd ~/
cmd mkdir $mkdir -p "$(echo $* | tr ' ' '\ ')"

# Limpiar todas las selecciones
cmd clear_selection ${{
	lf -remote "send $id clear"
	lf -remote "send $id glob-unselect *"
	lf -remote "send $id reload"
	clear
}}

cmd myclear ${{
	lf -remote "send $id reload"
	clear
}}

# Abrir archivos en función del tipo
cmd open ${{
	FILETYPE="$(xdg-mime query filetype "$(readlink -f $f)")"
	{
	case $FILETYPE in
		*/x-7z-compressed | */vnd.rar | */*-tar | */zip | */gzip)
			setsid -f xarchiver "$fx" ;;

		*/vnd.*document*)
			setsid -f libreoffice "$fx" ;;

		*/pdf | */epub* | */vnd.comicbook*)
			zathura "$f" ;;

		text/* | */xml | */json | inode/x-empty | */x-shellscript | */x-desktop | */yaml | */sql | */x-php)
			$EDITOR "$fx" ;;

		# Aveces xdg-mime y file detectan los archivos Xresources como x-xcursor
		image/x-xcursor)
			$EDITOR "$fx" ;;

		image/x-eps)
			HASH=$(
				stat --printf '%n\0%i\0%F\0%s\0%W\0%Y' -- "$(readlink -f "$f")" |
				sha256sum | awk '{print $1}'
			)
			CACHE="${XDG_CACHE_HOME:-$HOME/.cache}/lf/thumb.$HASH"
			[ ! -f "$CACHE.jpg" ] && \
				gs -dSAFER -dBATCH -dNOPAUSE -sDEVICE=jpeg -r300 -dEPSCrop \
					-sOutputFile="$CACHE.jpg" "$f"
			nsxiv "$CACHE.jpg"
			;;

		image/*)
			DIR="$(dirname -- "$f")"
			BASE="$(basename -- "$f")"

			# Listar imágenes en el directorio (ordenadas alfabéticamente)
			IMAGES=$(printf '%s\n' "$DIR"/*.{jpg,jpeg,png,gif,bmp,tiff,ppm,svg,webp,xpm} |
				grep -iE '\.(jpg|jpeg|png|gif|bmp|tiff|ppm|svg|webp|xpm)$' |
				sort -f)

			# Rotar la lista para que empiece en $BASE
			ROTATED=$(printf '%s\n' "$IMAGES" | awk -v start="$DIR/$BASE" '
				BEGIN { hit = 0 }
				$0 == start { hit = 1; print; next }
				{ if (hit) print; else buf = buf $0 ORS }
				END { if (buf != "") printf "%s", buf }
			')

			# Pasar a nsxiv
			printf '%s\n' "$ROTATED" |
				nsxiv -aio |
				while read -r FILE; do
					[ -z "$FILE" ] && continue
					lf -remote "send select \"$FILE\""
					lf -remote "send toggle"
				done &
			;;

		audio/*)
			mpv --audio-display=no "$f" ;;

		video/*)
			mpv "$f" ;;

		*/x-keepass2)
			setsid -f keepassxc "$f" ;;

		*/x-reaper-*)
			setsid -f reaper "$f" ;;

		*/x-tuxguitar | */gpx+xml | */x-gnuplot | */x-gtp)
			setsid -f tuxguitar "$fx" ;;

		# Si no tenemos configurada una forma de abrirlo, usamos xdg-open
		*) for f in $fx; do setsid -f $OPENER $f; done ;;
	esac
	} 2>/dev/null
}}

cmd on-cd &{{
	source /usr/share/git/completion/git-prompt.sh
	GIT_PS1_SHOWDIRTYSTATE=auto
	GIT_PS1_SHOWSTASHSTATE=auto
	GIT_PS1_SHOWUNTRACKEDFILES=auto
	GIT_PS1_SHOWUPSTREAM=auto
	GIT_PS1_COMPRESSSPARSESTATE=auto
	git="$(__git_ps1 " [GIT BRANCH:> %s]")" || true
	fmt="\033[32;1m%u@%h\033[0m:\033[34;1m%w\033[0m\033[33;1m$git\033[0m"
	lf -remote "send $id set promptfmt \"$fmt\""
}}

# Muestra información del archivo seleccionado con eza
cmd on-select &{{
	INFO="[$(/usr/bin/du -chs $fx | grep total | awk '{print $1}')"
	TOTAL_BYTES="$(stat -c %s "$fx")"
	if [ ! -d "$fx" ] && [ "$TOTAL_BYTES" -le 4096 ]; then
		INFO+=":${TOTAL_BYTES}B] "
	else
		INFO+="] "
	fi
	# Añadimos los permisos, dueño, fecha y nombre
	INFO+=$(
		eza -dlo --color=always --time-style iso "$(basename "$f")" |
			awk '{printf "%s %s %s %s %s %s", $1, $4, $5, $6, $7, $8; for (i=9; i<=NF; i++) printf " %s", $i; print ""}' |
			sed 's/\\/\\\\/g;s/"/\\"/g'
	)
	lf -remote "send $id set statfmt \"$INFO\""
}}

# Comprimir archivos dentro de un directorio en el formato seleccionado
cmd compress ${{
	# Ocultamos todas las notificaciones anteriores
	eval "$HIDE_NOTIFICATIONS"
	# Creamos un directorio para guardar todos los archivos comprimidos
	OUT_DIR="/tmp/00_Compressed"
	[ ! -e "$OUT_DIR" ] && mkdir -p "$OUT_DIR"

	# Convertir $fx en argumentos para los comandos de compresión
	SELECTED_FILES=$fx
	set -- $SELECTED_FILES
	# Si no hay archivos seleccionados, salir
	[ $# -eq 0 ] && exit 0

	# Determinar si los archivos provienen de directorios diferentes
	DIRS=$(dirname -z "$@" | tr '\0' '\n' | sort -u)
	NUM_DIRS=$(echo "$DIRS" | wc -l)

	if [ "$NUM_DIRS" -eq 1 ]; then
		# Si todos los archivos vienen del mismo directorio, usamos el nombre
		# del directorio para el archivo comprimido.
		BASE_NAME=$(basename "$DIRS")
	else
		# Si están en directorios distintos, le preguntamos al usuario por el
		# nombre del archivo comprimido
		BASE_NAME=$(
			whiptail --title "Nombre del archivo" \
				--inputbox "Ingrese el nombre del archivo comprimido:" 10 60 3>&1 1>&2 2>&3
		)
		[ -z "$BASE_NAME" ] && exit 0
	fi

	# Construimos una lista con los archivos a comprimir para que el usuario
	# pueda verificar que todo está correcto
	if [ "$(printf "%s\n" "$@" | wc -l)" -eq 1 ]; then
		LIST="$@"
	else
		# Si tenemos más de un archivo, imprimimos el 1o y el último
		LIST="$(printf "%s\n" "$@" | head -n1)\n"
		LIST+="...\n"
		LIST+="$(printf "%s\n" "$@" | tail -n1)"
	fi

	# Mostramos una lista con los archivos a comprimir
	whiptail \
		--title "Archivos seleccionados" \
		--yesno "$LIST\nComprimir en: $OUT_DIR/${BASE_NAME}.*" 10 60 ||
	exit 0

	# Preguntamos en que formato quiere comprimir los archivos
	FORMATO=$(
		whiptail \
			--title "Formato" \
			--menu "¿En qué formato desea comprimirlos?" \
			10 60 3 \
			"tar" "" \
			"zip" "" \
			"7z" "" \
			3>&1 1>&2 2>&3
	)

	# Preguntamos por el formato de compresión y comprimimos
	case "$FORMATO" in
		tar)
			ARCHIVO="$OUT_DIR/${BASE_NAME}.tar.gz"
			tar -zcvf "$ARCHIVO" "$@"
			;;
		7z)
			ARCHIVO="$OUT_DIR/${BASE_NAME}.7z"
			7z a "$ARCHIVO" "$@"
			;;
		zip)
			ARCHIVO="$OUT_DIR/${BASE_NAME}.zip"
			zip -r "$ARCHIVO" "$@"
			;;
	esac

	# Si los archivos se comprimieron correctamente, informamos al usuario
	[ -e "$ARCHIVO" ] &&
		notify-send -a lf -i ark "lf" "Archivo comprimido en\n<i>$OUT_DIR</i>"

	unset --

	# Deseleccionamos los archivos originales
	for file in $SELECTED_FILES; do
		lf -remote "send $id unselect \"$file\""
	done

	# Finalmente recargamos la pantalla y enfocamos el archivo creado
	lf -remote "send $id reload"
	lf -remote "send $id select \"$ARCHIVO\""
	clear
}}

# Función para abrir un scratchpad en el directorio actual
cmd cdterm &{{
	cd "$(dirname $f)"; eval "setsid -f $TERMINAL $TERMTITLE scratchpad"
}}

# Enviar una notificación con el tamaño del ítem seleccionado
cmd size &{{
	eval "$HIDE_NOTIFICATIONS"
	notify-send -a lf -i system-file-manager \
		"El tamaño es de $(/usr/bin/du -chs $fx | grep total | awk '{print $1}')"
}}

# Renombrar los contenido del directorio actual con nvim
cmd bulk-rename ${{
	old="$(mktemp)"
	new="$(mktemp)"
	if [ -n "$fs" ]; then
		fs="$(basename $fs)"
	else
		fs="$(ls)"
	fi
	printf '%s\n' "$fs" >"$old"
	printf '%s\n' "$fs" >"$new"
	$EDITOR "$new"
	[ "$(wc -l < "$new")" -ne "$(wc -l < "$old")" ] && exit
	paste "$old" "$new" | while IFS= read -r names; do
		src="$(printf '%s' "$names" | cut -f1)"
		dst="$(printf '%s' "$names" | cut -f2)"
		if [ "$src" = "$dst" ] || [ -e "$dst" ]; then
			continue
		fi
		mv -- "$src" "$dst"
	done
	rm -- "$old" "$new"
	/usr/bin/lf -remote "send $id unselect"
}}

# Buscar con fzf cadenas entre los archivos
cmd fzf_grep ${{
	cmd="rg --hidden --glob '!.git/*' --column --line-number --no-heading --color=always --smart-case"
	fzf --ansi --disabled --layout=reverse --delimiter=: \
		--bind="start:reload([ -n {q} ] && $cmd -- {q} || true)" \
		--bind="change:reload([ -n {q} ] && $cmd -- {q} || true)" \
		--bind='enter:become(lf -remote "send $id select \"$(printf "%s" {1} | sed '\''s/\\/\\\\/g;s/"/\\"/g'\'')\"")' \
		--preview='bat --color=always --highlight-line={2} -- {1}'
}}

# Elegir archivo con fzf
cmd fzf_search ${{
	res="$(find . | fzf --reverse --header='Ir a la localización')"
	if [ -n "$res" ]; then
		if [ -d "$res" ]; then
			cmd="cd"
		else
			cmd="select"
		fi
		res="$(printf '%s' "$res" | sed 's/\\/\\\\/g;s/"/\\"/g')"
		/usr/bin/lf -remote "send $id $cmd \"$res\""
	fi
	lf -remote "send $id reload"
}}

# Extraer archivo
cmd extract ${{
	eval "$HIDE_NOTIFICATIONS"
	whiptail --title "¿Extraer archivo(s)?" \
	--yesno "¿Quieres extraer el archivo $f?" 10 60 && \
	{
		case "$(xdg-mime query filetype "$f")" in
		*/x-zstd-compressed-tar)
			unzstd "$f"
			aunpack "$(basename -s .zst "$f")"
			rm "$(basename -s .zst "$f")"
			;;
		# Extraemos archivos con 7z para poder extraer archivos .zip fragmentados
		*/zip)
			OUT_DIR="${f%.zip}"
			mkdir -p "$OUT_DIR"
			7z x "$f" -o"$OUT_DIR"
			;;
		*) aunpack $f ;;
		esac
	} && \
	notify-send -a lf -i ark "lf" "Extraído:\n<i>$(basename $f)</i>"
}}

# Pegar archivos copiados/cortados
cmd paste $cp-p --lf-paste "$id"

# Mover a la papelera
cmd trash ${{
	eval "$HIDE_NOTIFICATIONS"
	clear
	tput bold
	set -f
	printf "%s\n\n" "$fx"
	printf "¿Mover archivo(s) a la papelera? [s/N] "
	read ans
	[ $ans = "s" ] && trash-put $fx &&
	notify-send -a lf -i user-trash "lf" "Archivo(s) movido(s) a la papelera"
	lf -remote "send $id reload"
}}

# Vaciar la papelera
cmd clean-trash ${{
	eval "$HIDE_NOTIFICATIONS"
	clear
	tput bold
	set -f
	printf "Contenidos de la papelera:\n"
	trash-list
	printf "¿Vaciar papelera? [s/N] "
	read ans
	if [ $ans = "s" ] || [ $ans = "S" ]; then
		trash-empty -f && \
		notify-send -a lf -i user-trash "lf" "Archivo(s) borrados"
	fi
	lf -remote "send $id reload"
}}

# Restaurar archivos de la papelera
cmd restore-trash ${{
	eval "$HIDE_NOTIFICATIONS"
	TRASH_CONTENTS=$(trash-list)
	if [ -z "$TRASH_CONTENTS" ]; then
		notify-send -a lf -i system-error "lf" "La papelera esta vacía"
		exit 0
	fi

	clear
	tput bold
	set -f
	echo $TRASH_CONTENTS | sed "s|$HOME|~|"
	printf "¿Restaurar? [s/N] "
	read ans
	[ $ans = "s" ]
	if [ $ans = "s" ] || [ $ans = "S" ]; then
		trash-restore
		notify-send -a lf -i user-trash "lf" "Archivo(s) restaurado(s)"
	fi
	lf -remote "send $id reload"
}}

on-cd

##########
# Atajos #
##########

# Limpiar selección
map <backspace2> clear_selection

# Limpiar pantalla
map R myclear
# Recargar configuración
map C &lf -remote "send $id source ~/.config/lf/lfrc"

# Pegar archivos
map p paste

# Renombrar archivos
map r rename
map <c-r> bulk-rename

# Gestionar papelera
map S trash
map D clean-trash
map F restore-trash

# Abrir scratchpad en el directorio actual
map s cdterm

# Cambiar de directorio
map <esc> home
map z home
map t cd /tmp
map T cd /run/media

# Buscar archivo
map / :fzf_search
map <c-_> :fzf_grep

# Extraer/comprimir archivos
map E extract
map <c-e> compress

# Mostrar/ocultar los archivos ocultos
map h set hidden!

# Abrir/crear archivo con vim
map V push :!nvim<space>$f


# Abrir archivos
cmd open-with %export ; "$@" "$fx"
map <enter> push :open-with<space>

# Permitir arrastrar archivos hacia otra ventana
map <c-z> $setsid -f dragon-drop -a -x $fx

# Notificar del tamaño de los ítemes actuales
map P size

# Crear directorio
map m push %mkdir<space>

# Copiar el directorio del archivo actual al portapapeles
map Y ${{
	eval "$HIDE_NOTIFICATIONS"
	printf '"%s"' "$(dirname "$fx")" | wl-copy
	notify-send -a lf -i gpaste "lf" "Ruta copiada al portapapeles"
}}

# Salir del programa
map q ${{
	# Restaurar el título original de la ventana
	printf '\033]0;\007'
	/usr/bin/lf -remote "send $id quit"
}}

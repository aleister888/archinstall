set shell bash
set ifs "\n"
set scrolloff 10
set icons
set relativenumber
set info size:time
set ratios 2:6:4
set autoquit true
set hiddenfiles ".*:*.aux:*.toc:*.sty:*.out:*.bbl:*.blg:*.synctex.gz:_minted:*.bcf:*.nav:*.run.xml:*.snm:*.xwm:*.lrc:*-autosave.kra:*~:*.vpp.bak_*:systemd-private-*"

set cleaner   '~/.config/lf/cleaner'
set previewer '~/.config/lf/previewer'

# Atajos
#-------------------------------------------------------------------------------

map C &lf -remote "send $id source ~/.config/lf/lfrc"

map p paste
cmd paste $cp-p --lf-paste "$id"

map r rename

map h set hidden!

map <esc> cd ~/
map z cd ~/
map t cd /tmp
map T cd /run/media

map V push :!nvim<space>$f

map <c-z> drag-and-drop
cmd drag-and-drop $setsid -f dragon-drop -a -x $fx

map <enter> push :open-file-with<space>
cmd open-file-with %export ; setsid -f "$@" "$fx"

cmd mkdir $mkdir -p "$(echo $* | tr ' ' '\ ')"
map m push :mkdir<space>

map Y copy-filepath
cmd copy-filepath ${{
	eval "$HIDE_NOTIFICATIONS"
	printf '"%s"' "$(dirname "$fx")" | wl-copy
	notify-send -t 1200 -e "lf" "Ruta copiada al portapapeles"
}}

map q quit
cmd quit ${{
	# Restaurar el título de la terminal
	printf '\033]0;\007'
	/usr/bin/lf -remote "send $id quit"
}}

#-------------------------------------------------------------------------------

map <backspace2> clear_file_selection
cmd clear_file_selection ${{
	lf -remote "send $id unselect"
	lf -remote "send $id reload"
	lf -remote "send $id clear"
}}

map R clear_screen
cmd clear_screen ${{
	lf -remote "send $id reload"
	lf -remote "send $id clear"
}}

#-------------------------------------------------------------------------------

map s open_scratch_in_cwd
cmd open_scratch_in_cwd &{{
	cd "$(dirname $f)"; eval "setsid -f $TERMINAL $SCRATCH_OPTS $TERMTITLE scratchpad"
}}

# Comprimir/descomprimir archivos
#-------------------------------------------------------------------------------

map <c-e> compress
cmd compress ${{
	export LF_ID="$id"
	~/.config/lf/compress-files $fx
}}

map E extract
cmd extract ${{
	eval "$HIDE_NOTIFICATIONS"
	if whiptail --title "¿Extraer archivo(s)?" \
		--yesno "¿Quieres extraer el archivo $f?" 10 60; then

		case "$(file -b --mime-type "$(readlink -f $f)")" in
		*/x-zstd-compressed-tar)
			unzstd "$f"
			aunpack "$(basename -s .zst "$f")"
			rm "$(basename -s .zst "$f")" ;;
		*/zip) # Usamos 7z para poder extraer archivos .zip fragmentados
			OUT_DIR="${f%.*}"
			mkdir -p "$OUT_DIR"
			7z x "$f" -o"$OUT_DIR" ;;
		*) aunpack $f ;;
		esac
	fi &&
		notify-send -t 1200 -e "lf" "Extraído:\n<i>$(basename $f)</i>"
}}

#-------------------------------------------------------------------------------

map P notify_filesize
cmd notify_filesize &{{
	FILE_SIZE="$(/usr/bin/du -chs $(readlink -f $fx) | grep total | awk '{print $1}')"

	eval "$HIDE_NOTIFICATIONS"
	notify-send -t 1200 -e "lf" "El tamaño es de $FILE_SIZE"
}}

# Renombrar los contenido del directorio actual con nvim
#-------------------------------------------------------------------------------

map <c-r> bulk-rename
cmd bulk-rename ${{
	old="$(mktemp)"
	new="$(mktemp)"
	if [ -n "$fs" ]; then
		fs="$(basename $fs)"
	else
		fs="$(ls)"
	fi
	printf '%s\n' "$fs" >"$old"
	printf '%s\n' "$fs" >"$new"
	$EDITOR "$new"
	[ "$(wc -l < "$new")" -ne "$(wc -l < "$old")" ] && exit
	paste "$old" "$new" | while IFS= read -r names; do
		src="$(printf '%s' "$names" | cut -f1)"
		dst="$(printf '%s' "$names" | cut -f2)"
		if [ "$src" = "$dst" ] || [ -e "$dst" ]; then
			continue
		fi
		mv -- "$src" "$dst"
	done
	rm -- "$old" "$new"
	/usr/bin/lf -remote "send $id unselect"
}}

# Buscar archivos con fzf
#-------------------------------------------------------------------------------

map <c-_> fzf_grep
cmd fzf_grep ${{
	cmd="rg --hidden --glob '!.git/*' --column --line-number --no-heading --color=always --smart-case"
	fzf --ansi --disabled --layout=reverse --delimiter=: \
		--bind="start:reload([ -n {q} ] && $cmd -- {q} || true)" \
		--bind="change:reload([ -n {q} ] && $cmd -- {q} || true)" \
		--bind='enter:become(lf -remote "send $id select \"$(printf "%s" {1} | sed '\''s/\\/\\\\/g;s/"/\\"/g'\'')\"")' \
		--preview='bat --color=always --highlight-line={2} -- {1}' || true
}}

map / fzf_search
cmd fzf_search ${{
	res="$(find . | fzf --reverse --header='Ir a la localización')"
	if [ -n "$res" ]; then
		if [ -d "$res" ]; then
			cmd="cd"
		else
			cmd="select"
		fi
		res="$(printf '%s' "$res" | sed 's/\\/\\\\/g;s/"/\\"/g')"
		/usr/bin/lf -remote "send $id $cmd \"$res\""
	fi
	lf -remote "send $id reload"
}}

# Mover a la papelera
#-------------------------------------------------------------------------------

map S trash
cmd trash ${{
	clear; tput bold; set -f

	printf "%s\n\n" "$fx"
	printf "¿Mover archivo(s) a la papelera? [s/N] "
	read ans

	if [ $ans = "s" ] && trash-put $fx; then
		eval "$HIDE_NOTIFICATIONS"
		notify-send -t 1200 -e "lf" "Archivo(s) movido(s) a la papelera"
	fi

	lf -remote "send $id reload"
	clear
}}

# Vaciar la papelera
#-------------------------------------------------------------------------------

map D empty-trash
cmd empty-trash ${{
	TRASH_CONTENTS=$(trash-list)

	if [ -z "$TRASH_CONTENTS" ]; then
		notify-send -t 1200 -e "lf" "La papelera esta vacía"
		exit
	fi

	clear; tput bold; set -f

	printf "Contenidos de la papelera:\n%s\n\n" "$TRASH_CONTENTS"
	printf "¿Vaciar papelera? [s/N] "
	read ans

	if [ $ans = "s" ] && trash-empty -f; then
		eval "$HIDE_NOTIFICATIONS"
		notify-send -t 1200 -e "lf" "Archivo(s) borrados"
	fi

	lf -remote "send $id reload"
	clear
}}

# Restaurar archivos de la papelera
#-------------------------------------------------------------------------------

map F restore-trash
cmd restore-trash ${{
	TRASH_CONTENTS=$(trash-list)

	if [ -z "$TRASH_CONTENTS" ]; then
		notify-send -t 1200 -e "lf" "La papelera esta vacía"
		exit
	fi

	clear; tput bold; set -f

	echo -e "$TRASH_CONTENTS\n" | sed "s|$HOME|~|"
	printf "¿Restaurar? [s/N] "
	read ans

	if [ $ans = "s" ] && trash-restore && [ "$TRASH_CONTENTS" != "$(trash-list)" ]; then
		eval "$HIDE_NOTIFICATIONS"
		notify-send -t 1200 -e "lf" "Archivo(s) restaurado(s)"
	fi

	lf -remote "send $id reload"
	clear
}}

# Comandos reservados de lf
#-------------------------------------------------------------------------------

cmd on-cd &{{
	source /usr/share/git/completion/git-prompt.sh
	git="$(__git_ps1 " [branch:> %s]")" || true
	fmt="\033[32;1m%u@%h\033[0m:\033[34;1m%w\033[0m\033[33;1m$git\033[0m"
	lf -remote "send $id set promptfmt \"$fmt\""
}}

cmd open ${{
	~/.config/lf/opener-caller $fx
}}

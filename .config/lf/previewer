#!/bin/bash
# shellcheck disable=SC1091

# Visualizador de archivos para LF.

source "$HOME/.dotfiles/assets/shell/shell-utils-sh"

LF_CACHE_DIR="$(ensure_dir "${XDG_CACHE_HOME:-$HOME/.cache}/lf")"

W="$2"
H="$3"
Y="$5"
X="$4"

# WARN: El script genera una imagen de preview para lf e imprime un texto con
# información sobre el archivo. Queremos que el script también sirva para
# generar la imagen de preview e imprimir su ruta.
#
# Para ello en definimos la siguiente función:
called_from_lf() { [ -n "$LF_LEVEL" ]; }

# Calcula e imprime los saltos de línea necesarios para que la información sobre
# el archivo no se vea solapada por la imagen del preview
linebreaks() {
	local PREVIEW="$1"

	HEIGHT=$(mediainfo "$PREVIEW" | grep -oP "Height[ ]*: \K.[0-9 ]*" | tr -d ' ')
	WIDTH=$(mediainfo "$PREVIEW" | grep -oP "Width[ ]*: \K.[0-9 ]*" | tr -d ' ')
	RATIO=$(echo "scale=3; $WIDTH / $HEIGHT " | bc)
	COUNT=$(echo "(${X}/4) / $RATIO + 2" | bc)

	for ((i = 0; i < COUNT; i++)); do
		echo
	done
}

display() {
	[ -f "$1" ] || return 1

	# Si usamos scope fuera de lf simplemente se imprime la ruta de la imagen
	if ! called_from_lf; then
		echo "$1"
	elif ! is_ssh && [ -n "$WAYLAND_DISPLAY" ]; then
		kitten icat --stdin no --transfer-mode memory --place "${W}x${H}@${X}x${Y}" "$1" </dev/null >/dev/tty
	else
		echo "SSH/TTY preview unsupported"
		return 1
	fi
}

# Función para extraer el hash de un archivo
file_hash() {
	stat --printf '%n\0%i\0%F\0%s\0%W\0%Y' -- "$(readlink -f "$1")" |
		sha256sum | awk '{print $1}'
}

# Función para la preview de archivos que se pueden convertir con ImageMagick directamente
magick_convert() {
	CACHE="$LF_CACHE_DIR/thumb.$HASH"
	[ ! -f "$CACHE.jpg" ] && magick "$1" "$CACHE.jpg" &>/dev/null
	display "$CACHE.jpg"
}

thumbnail_resize() {
	[ -z "$WAYLAND_DISPLAY" ] || [ -n "$SSH_CONNECTION" ] && return
	THUMBNAIL="$1"
	# Ancho mínimo: 1/3 del ancho de pantalla
	THIRD="$(($(hyprctl monitors -j | jq '.[] | select(.focused == true)' | jq -r '.width') / 3))"
	WIDTH=$(identify -format "%w" "$THUMBNAIL")
	# Si el ancho es menor al requerido, lo re-escalamos proporcionalmente
	if [ "$WIDTH" -lt "$THIRD" ]; then
		TMP="$(mktemp /tmp/lf.XXXXXX.jpg)"
		convert "$THUMBNAIL" -resize "${THIRD}x" "$TMP" &>/dev/null
		mv -f "$TMP" "$THUMBNAIL"
	fi
}

FILETYPE="$(xdg-mime query filetype "$1")"
HASH="$(file_hash "$1")"

case $FILETYPE in

# Mostrar imágenes y texto
#-------------------------------------------------------------------------------

audio/flac | audio/mpeg | audio/x-m4a | audio/mp4) # Carátula y metadatos
	CACHE_DIR="$LF_CACHE_DIR/$HASH"
	METADATA="$CACHE_DIR/metadata.txt"
	COVER="$CACHE_DIR/cover.jpg"

	ensure_dir "$CACHE_DIR" >/dev/null

	[ ! -f "$COVER" ] && { ffmpeg -nostdin -i "$1" "$COVER" && thumbnail_resize "$COVER"; } &>/dev/null

	if [ ! -f "$METADATA" ]; then
		TMP="$(mktemp /tmp/lf.XXXX)"
		ffmpeg -i "$1" -y -f ffmetadata "$TMP"

		[ "$FILETYPE" = "audio/flac" ] &&
			mediainfo --Inform="Audio;%BitDepth% bit / %SamplingRate% Hz" "$1" | tee "$METADATA"
		grep -ivE "(comment|encoder|ffmetadata1)" "$TMP" | tee -a "$METADATA"

		rm -f "$TMP"
	fi &>/dev/null

	display "$COVER" &&
		if called_from_lf; then
			linebreaks "$COVER"
			cat "$METADATA"
		fi
	;;

video/*) # Thumbnail y metadatos
	CACHE_DIR="$LF_CACHE_DIR/$HASH"
	THUMBNAIL="$CACHE_DIR/thumbnail.jpg"
	METADATA="$CACHE_DIR/metadata.txt"

	ensure_dir "$CACHE_DIR" >/dev/null

	if [ ! -f "$THUMBNAIL" ]; then
		ffmpegthumbnailer -i "$1" -o "$THUMBNAIL" -s 0 &&
			thumbnail_resize "$THUMBNAIL"
	fi &>/dev/null

	if [ ! -f "$METADATA" ]; then
		TMP="$(mktemp /tmp/lf.XXXX)"
		mediainfo "$1" | tr '\t' ' ' | tr -s " " | tee "$TMP"

		for FIELD in "File size" "Duration" "Frame rate" "Format" "Width" "Height" "Bit depth"; do
			grep "^$FIELD" "$TMP" | head -n1 >>"$METADATA"
		done
		grep "^Language" "$TMP" | sort -u >>"$METADATA"

		rm "$TMP"
	fi &>/dev/null

	display "$THUMBNAIL" &&
		if called_from_lf; then
			linebreaks "$THUMBNAIL"
			cat "$METADATA"
		fi
	;;

*/x-krita) # Preview y listado de archivos
	CACHE_DIR="$LF_CACHE_DIR/$HASH"
	PREVIEW="$CACHE_DIR/preview.png"
	FILE_LIST="$CACHE_DIR/filelist.txt"

	ensure_dir "$CACHE_DIR" >/dev/null

	[ ! -f "$FILE_LIST" ] && unzip -l "$1" | tee "$FILE_LIST" >/dev/null
	[ ! -f "$PREVIEW" ] && { 7z e "$1" preview.png -o"$CACHE_DIR" && thumbnail_resize "$PREVIEW"; } &>/dev/null

	display "$PREVIEW" &&
		if called_from_lf; then
			linebreaks "$PREVIEW"
			cat "$FILE_LIST"
		fi
	;;

# Mostrar solo imágenes
#-------------------------------------------------------------------------------

image/svg+xml*)
	CACHE_FILE="$LF_CACHE_DIR/$HASH.png"
	[ ! -f "$CACHE_FILE" ] && DISPLAY="" inkscape -o "$CACHE_FILE" --export-overwrite -D --export-width=256 "$1" &>/dev/null
	display "$CACHE_FILE"
	;;

image/x-eps)
	CACHE_FILE="$LF_CACHE_DIR/$HASH.jpg"
	[ ! -f "$CACHE_FILE" ] && gs -dSAFER -dBATCH -dNOPAUSE -sDEVICE=jpeg -r300 -dEPSCrop -sOutputFile="$CACHE_FILE" "$1" &>/dev/null
	display "$CACHE_FILE"
	;;

*/pdf)
	CACHE_FILE="$LF_CACHE_DIR/$HASH.jpg"
	# Usando -dUseCropBox usamos la parte visible de la página en vez de
	# mantener el tamaño de página definido en el PDF
	[ ! -f "$CACHE_FILE" ] && gs -sDEVICE=jpeg -dUseCropBox -dFirstPage=1 -dLastPage=1 -r300 -o "$CACHE_FILE" "$1" &>/dev/null
	display "$CACHE_FILE"
	;;

*/vnd.comicbook+zip | */vnd.comicbook-rar | */epub+zip) # Primera página
	CACHE_FILE="$LF_CACHE_DIR/$HASH"
	FIRST_IMAGE=$(7z l "$1" | grep 'jp[e]*g\|png' | awk '{print substr($0, index($0,$6))}' | sort | head -n1)
	EXTENSION=${FIRST_IMAGE//*./}
	CACHE_FILE+=".${EXTENSION}"

	if [ ! -f "$CACHE_FILE" ]; then
		[ -z "$FIRST_IMAGE" ] && exit

		TMP_DIR="$(get_tmp_dir lf)"

		7z e "$1" "$FIRST_IMAGE" -o"$TMP_DIR"
		mv -f "$TMP_DIR/$(basename "$FIRST_IMAGE")" "$CACHE_FILE"
		rm -rf "$TMP_DIR"
	fi &>/dev/null

	display "$CACHE_FILE"
	;;

*/postscript | */x-xpixmap | */x-xcf | */heif | */bmp) magick_convert "$1" ;;
image/*) display "$1" ;;

# Mostrar solo texto
#-------------------------------------------------------------------------------

text/troff) called_from_lf &&
	man ./ "$1" | col -b ;;

*/vnd.rar | */zip | */vnd.android.package-archive | */x-7z-compressed) called_from_lf &&
	7z l "$1" ;;

*/json*) called_from_lf &&
	bat -fp --terminal-width "$((4 - 2))" -l JSON "$1" ;;

*/pgp-encrypted) called_from_lf &&
	gpg --list-packets "$1" ;;

*/x-tar | */x-compressed-tar) called_from_lf &&
	tar -tf "$1" ;;

*opendocument*) called_from_lf &&
	odt2txt "$1" ;;

*/x-iso9660-image | */vnd.efi.iso) # Metadatos
	CACHE_FILE="$LF_CACHE_DIR/$HASH.txt"

	if [ ! -f "$CACHE_FILE" ]; then
		isoinfo -d -i "$1" |
			grep "Volume id\|Publisher\|Data preparer\|Application" |
			tee "$CACHE_FILE"
	fi &>/dev/null

	called_from_lf && cat "$CACHE_FILE"
	;;

*/mathematica) called_from_lf && bat -fp -l C "$1" ;;

text/plain)
	called_from_lf || exit

	case "${1##*.}" in
	# Para archivos de texto plano nos fijamos en la extensión
	hjson) bat -fp -l JSON <<<"$(hjson -j "$1")" ;;
	*) bat -fp --terminal-width "$((4 - 2))" -f "$1" ;;
	esac
	;;

text/* | */xml | */x-shellscript | */x-xcursor | */x-theme | */x-desktop | \
	*/x-troff-man | */x-ruby | */yaml | */toml | */sql | */x-php | */x-empty | \
	*/x-xbel | */x-subrip)
	called_from_lf || exit

	case "$(file --dereference --brief --mime-type -- "$1")" in
	*/pgp-keys) gpg --list-packets "$1" ;;
	*/*) bat -fp --terminal-width "$((4 - 2))" -f "$1" ;;
	esac
	;;

*) called_from_lf &&
	mediainfo "$1" | tr -s " " ;;

esac

# El código de salida debe de ser !=0 para limpiar la pantalla correctamente
exit 1

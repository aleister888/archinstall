#!/bin/sh

export LOG_BASE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/dotfiles_log"
export CACHE_BASE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/dotfiles_cache"
export TMP_BASE_DIR="/tmp/00_dotfiles"

ensure_dir() {
	[ ! -d "$1" ] && mkdir -p "$1"
	echo "$1"
}

delete_broken_symlinks() {
	find "$1" -type l ! -exec test -e {} \; -delete
}

# Utilidades para guardar los logs en un solo directorio
#
# Podemos guardar los logs en un directorio relativo al base usando:
#     initlog <directorio>
#       => logs guardados en $LOG_BASE_DIR/<directorio>
#
# o para que la actualización de la variable LOG_DIR sea más explícita:
#     LOG_DIR=$(init_log <directorio>)
#-------------------------------------------------------------------------------

print_msg() {
	_msg="$1"
	_level="${2:-INFO}"
	_date="${3:-$(date '+%Y-%m-%d %H:%M:%S')}"
	_module="${4:-$(basename "$0")}"

	printf "%s [%s] (%s) %s\n" "$_date" "$_level" "$_module" "$_msg"
}

log() {
	_msg="$1"
	_level="${2:-ERROR}"
	_date="$(date '+%Y-%m-%d %H:%M:%S')"
	_module="$(basename "$0")"

	# Cuando se ejecuta directamente desde el shell interactivo $0=log
	[ "$_module" = "log" ] && _module="shell"

	ensure_dir "${LOG_DIR:-$LOG_BASE_DIR}" >/dev/null

	print_msg "$_msg" "$_level" "$_date" "$_module" |
		tee -a "${LOG_DIR:-$LOG_BASE_DIR}/errors.log"
}

init_log() {
	LOG_DIR="$LOG_BASE_DIR/$1"
	ensure_dir "$LOG_DIR"
}

# Utilidades para guardar los archivos temporales en un solo directorio
#-------------------------------------------------------------------------------

get_tmp() {
	ensure_dir "$TMP_BASE_DIR/$1"
}

get_random_tmp() {
	ensure_dir "$TMP_BASE_DIR" >/dev/null
	mktemp -d -p "$TMP_BASE_DIR" XXXXXX
}

# A veces necesitaremos trabajar sobre el directorio ~/.cache porque tmp tiene
# limitaciones de tamaño. Importante tener en cuenta que como el contenido de
# ~/.cache no se borra solo, se debe borrar explicitamente el directorio
# $CACHE_DIR al terminar de utilizarlo
get_cache_tmp() {
	_cache_dir="$CACHE_BASE_DIR/$1"
	_tmp_symlink="$TMP_BASE_DIR/$1"

	ensure_dir "$_cache_dir"
	ensure_dir "$TMP_BASE_DIR" >/dev/null

	# Creamos un enlace simbólico en el directorio temporal centralizado
	rm -rf "$_tmp_symlink"
	ln -sf "$_cache_dir" "$_tmp_symlink"

	trap 'delete_broken_symlinks "$TMP_BASE_DIR"' EXIT
}

#-------------------------------------------------------------------------------

is_chroot() {
	sudo /usr/bin/systemd-detect-virt --chroot >/dev/null 2>&1
}

has_bluetooth_device() {
	{
		lspci
		lsusb
	} | grep -qi bluetooth
}

has_wifi_device() {
	{
		lspci
		lsusb
	} | grep -qi wireless
}

#-------------------------------------------------------------------------------

download() {
	_url="$1"
	_file="$2"
	if [ ! -f "$_file" ]; then
		ensure_dir "$(dirname "$_file")"
		if curl "$_url" -o "$_file" 2>/dev/null; then
			return
		else
			log "file could not be downloaded: $_file"
		fi
	fi

	#log "file already exists: $file" WARN
}

remove_comments() {
	cat "$1" | grep -v "^[ \t]*//"
}

check_command() {
	if ! command -v "$1" >/dev/null 2>&1; then
		log "El comando $1 no se encontró"
		exit 1
	fi
}

check_connection() {
	_check_url="${1:-https://dns.google/}"
	curl -s --connect-timeout 3 "$_check_url" >/dev/null
}

# Comprobar si un script se esta ejecutando, teniendo en cuenta que este
# puede estar editandose en una terminal
is_process_running() {
	_process_name="$1"
	if [ "$_process_name" = "$EDITOR" ] || [ "$_process_name" = "$BROWSER" ]; then
		pgrep -f --quiet "$_process_name"
	else
		pgrep -f -a "$_process_name" | grep -qv "$EDITOR\|$BROWSER"
	fi
}

# Obtener el nombre del proceso padre
get_parent_process() {
	ps -p $PPID -o cmd | tail -n1
}

#-------------------------------------------------------------------------------

get_partition_name() {
	_block_device="$1"
	_number="$2"
	case "$_block_device" in
	*"nvme"* | *"mmcblk"*) echo "${_block_device}p${_number}" ;;
	*) echo "${_block_device}${_number}" ;;
	esac
}

sudoloop() {
	sudo -v
	while true; do
		sudo -n true
		sleep 60
		kill -0 "$$" || exit
	done 2>/dev/null &
}

get_monitor_resolution() {
	_n_monitor=${1:-1}
	hyprctl monitors |
		grep -v "availableModes" | grep -oP "\d+x\d+(?=@)" |
		head -n"$_n_monitor"
}

# Funciones para informar sobre el número de paquetes instalados
#-------------------------------------------------------------------------------

_pacman_count_file=$TMP_BASE_DIR/pacman_pkg_count
_aur_count_file=$TMP_BASE_DIR/aur_pkg_count
_nix_count_file=$TMP_BASE_DIR/nix_pkg_count

package_info_update() {
	_pacman_count="$(yay -Q | wc -l)" &&
		echo "$_pacman_count" >$_pacman_count_file
	_aur_count="$(yay -Qm | wc -l)" &&
		echo "$_aur_count" >$_aur_count_file
	_nix_count="$(nix profile list --json 2>/dev/null | jq -c '.elements | to_entries[]' | wc -l)" &&
		echo "$_nix_count" >$_nix_count_file
}

package_info_print() {
	[ ! -e "$_pacman_count_file" ] && return 1
	[ ! -e "$_aur_count_file" ] && return 1
	[ ! -e "$_nix_count_file" ] && return 1

	printf "pacman: %s (aur: %s), nix: %s\n" \
		"$(/usr/bin/cat $_pacman_count_file)" \
		"$(/usr/bin/cat $_aur_count_file)" \
		"$(/usr/bin/cat $_nix_count_file)"
}

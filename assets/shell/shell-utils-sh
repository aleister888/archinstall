#!/bin/sh

export LOG_BASE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/dotfiles_log"
export CACHE_BASE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/dotfiles_cache"
export TMP_BASE_DIR="/tmp/00_dotfiles"

ensure_dir() {
	[ ! -d "$1" ] && mkdir -p "$1"
	echo "$1"
}

delete_broken_symlinks() {
	[ -d "$1" ] && find "$1" -type l ! -exec test -e {} \; -delete
}

# Función para obtener la fecha en el formato ISO 8601
get_date() {
	date +'%Y-%m-%dT%H:%M:%S%z'
}

# Utilidades para guardar los logs en un solo directorio
#
# Podemos guardar los logs en un directorio relativo al base usando:
#     get_log_dir <directorio> => LOG_DIR=$LOG_BASE_DIR/<directorio>
#
# para que la actualización de la variable LOG_DIR sea más explícita:
#     LOG_DIR="$(get_log_dir <directorio>)"
#-------------------------------------------------------------------------------

print_msg() {
	_msg="$1"
	_level="${2:-INFO}"
	_module="${3:-$(basename "$0")}"
	_date="$(get_date)"

	printf "[%s] [%s] %s: %s\n" "$_date" "$_module" "$_level" "$_msg"
}

log() {
	_msg="$1"
	_level="${2:-ERROR}"
	_filename="${3:-errors.log}"
	_module="$(basename "$0")"

	# Cuando se ejecuta directamente desde el shell interactivo $0=log
	[ "$_module" = "log" ] && _module="shell"

	ensure_dir "${LOG_DIR:-$LOG_BASE_DIR}" >/dev/null

	print_msg "$_msg" "$_level" "$_module" |
		tee -a "${LOG_DIR:-$LOG_BASE_DIR}/$_filename"
}

get_log_dir() {
	if [ -z "$1" ]; then
		LOG_DIR="$LOG_BASE_DIR"
	else
		LOG_DIR="$LOG_BASE_DIR/$1"
	fi
	ensure_dir "$LOG_DIR"
}

# Utilidades para guardar los archivos temporales en un solo directorio
#
# Podemos depositar los archivos temporales en un directorio relativo al base usando:
#     get_tmp_dir <directorio> => TMP_DIR=$TMP_BASE_DIR/<directorio>
#
# para que la actualización de la variable TMP_DIR sea más explícita:
#     TMP_DIR="$(get_tmp_dir <directorio>)"
#-------------------------------------------------------------------------------

get_random_tmp_dir() {
	ensure_dir "$TMP_BASE_DIR" >/dev/null
	mktemp -d -p "$TMP_BASE_DIR" XXXXXX
}

get_tmp_dir() {
	if [ -z "$1" ]; then
		get_random_tmp_dir
	else
		TMP_DIR="$TMP_BASE_DIR/$1"
		ensure_dir "$TMP_DIR"
	fi
}

# A veces necesitaremos trabajar sobre el directorio ~/.cache porque tmp tiene
# limitaciones de tamaño. Importante tener en cuenta que como el contenido de
# ~/.cache no se borra solo, se debe borrar explicitamente el directorio
# $CACHE_DIR al terminar de utilizarlo
get_cache_tmp_dir() {
	_cache_dir="$CACHE_BASE_DIR/$1"
	_tmp_symlink="$TMP_BASE_DIR/$1"

	ensure_dir "$_cache_dir"
	ensure_dir "$TMP_BASE_DIR" >/dev/null

	# Creamos un enlace simbólico en el directorio temporal centralizado
	rm -rf "$_tmp_symlink"
	ln -sf "$_cache_dir" "$_tmp_symlink"

	trap 'delete_broken_symlinks "$TMP_BASE_DIR"' EXIT
}

# Funciones para informar sobre el número de paquetes instalados
#-------------------------------------------------------------------------------

_pacman_count_file=$TMP_BASE_DIR/pacman_pkg_count
_aur_count_file=$TMP_BASE_DIR/aur_pkg_count
_nix_count_file=$TMP_BASE_DIR/nix_pkg_count

package_info_update() {
	_pacman_count="$(yay -Q | wc -l)" &&
		echo "$_pacman_count" >$_pacman_count_file
	_aur_count="$(yay -Qm | wc -l)" &&
		echo "$_aur_count" >$_aur_count_file
	_nix_count="$(nix profile list --json 2>/dev/null | jq -c '.elements | to_entries[]' | wc -l)" &&
		echo "$_nix_count" >$_nix_count_file
}

package_info_print() {
	[ ! -e "$_pacman_count_file" ] && return 1
	[ ! -e "$_aur_count_file" ] && return 1
	[ ! -e "$_nix_count_file" ] && return 1

	printf "pacman: %s (aur: %s), nix: %s\n" \
		"$(/usr/bin/cat $_pacman_count_file)" \
		"$(/usr/bin/cat $_aur_count_file)" \
		"$(/usr/bin/cat $_nix_count_file)"
}

# One-liners
#-------------------------------------------------------------------------------

get_devices() {
	lspci
	lsusb
}

has_bluetooth_device() { get_devices | grep -qi bluetooth; }
has_wifi_device() { get_devices | grep -qi wireless; }
get_parent_process() { ps -p $PPID -o cmd | tail -n1; }
remove_comments() { cat "$1" | grep -v "^[ \t]*//"; }
is_chroot() { sudo /usr/bin/systemd-detect-virt --chroot >/dev/null 2>&1; }
check_connection() { curl -s --connect-timeout 3 "${1:-https://dns.google/}" >/dev/null; }

#-------------------------------------------------------------------------------

download() {
	_url="$1"
	_file="$2"
	[ -f "$_file" ] && return 0

	ensure_dir "$(dirname "$_file")" >/dev/null
	curl "$_url" -o "$_file" 2>/dev/null && return 0

	log "el archivo no pudo descargarse: $_file"
	return 1
}

check_command() {
	if ! command -v "$1" >/dev/null 2>&1; then
		log "el comando $1 no se encontró"
		exit 1
	fi
}

# Comprobar si un script se esta ejecutando, teniendo en cuenta que este
# puede estar editandose en una terminal
is_process_running() {
	_process_name="$1"
	if [ "$_process_name" = "$EDITOR" ] || [ "$_process_name" = "$BROWSER" ]; then
		pgrep -f --quiet "$_process_name"
	else
		pgrep -f -a "$_process_name" | grep -qv "$EDITOR\|$BROWSER"
	fi
}

# Obtener el nombre que tendría la partición número n en función del tipo
# de dispositivo
get_partition_name() {
	_block_device="$1"
	_number="$2"
	case "$_block_device" in
	*"nvme"* | *"mmcblk"*) echo "${_block_device}p${_number}" ;;
	*) echo "${_block_device}${_number}" ;;
	esac
}

# Ejecutar sudo en un bucle para evitar timeouts
sudoloop() {
	sudo -v
	while true; do
		sudo -n true
		sleep 60
		kill -0 "$$" || exit
	done 2>/dev/null &
}

# Obtener la resolución del monitor número n
get_monitor_resolution() {
	_n_monitor=${1:-1}
	hyprctl monitors |
		grep -v "availableModes" | grep -oP "\d+x\d+(?=@)" |
		head -n"$_n_monitor"
}

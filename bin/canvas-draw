#!/usr/bin/python3
import tkinter as tk
from PIL import Image, ImageDraw
import argparse
import os
import subprocess
import tempfile

parser = argparse.ArgumentParser()
parser.add_argument("-l", "--latex", action="store_true")
parser.add_argument("-q", "--quiet", action="store_true")
args = parser.parse_args()

willLatex = args.latex
quiet = args.quiet

STROKE_WIDTH = 4

if willLatex:
    canvas_width = 1800
    canvas_height = 400
    BG_COLOR = "#ffffff"
    GRID_COLOR = "#f4f4f4"
    STROKE_COLOR = "#000000"
else:
    canvas_width = 1600
    canvas_height = canvas_width // 16 * 9
    BG_COLOR = "#282828"
    GRID_COLOR = "#3c3836"
    STROKE_COLOR = "#fbf1c7"


# Canvas
WINTITLE = "Lienzo en blanco"
grid_squares = canvas_width // 35
grid_size = canvas_width // grid_squares

# Trazos
last_x, last_y = None, None
current_stroke = []
strokes = []

# Modo borrar
erase_mode = False
erase_radius = 10

# Historial de acciones
actions = []
# Pila para rehacer
redo_stack = []

# Imagen PIL
image = Image.new("RGB", (canvas_width, canvas_height), BG_COLOR)
draw = ImageDraw.Draw(image)

#############
# Funciones #
#############

def draw_grid():
    for x in range(0, canvas_width, grid_size):
        canvas.create_line(x, 0, x, canvas_height, fill=GRID_COLOR, width=2, tags=("grid",))
    for y in range(0, canvas_height, grid_size):
        canvas.create_line(0, y, canvas_width, y, fill=GRID_COLOR, width=2, tags=("grid",))

def start_paint(event):
    global last_x, last_y, current_stroke
    if erase_mode:
        start_erase(event)
    else:
        last_x, last_y = event.x, event.y
        current_stroke = []

def paint(event):
    global last_x, last_y, current_stroke
    if erase_mode:
        erase(event)
        return
    if last_x is not None and last_y is not None:
        line_id = canvas.create_line(last_x, last_y, event.x, event.y,
                                     fill=STROKE_COLOR, width=STROKE_WIDTH, capstyle=tk.ROUND, smooth=True)
        current_stroke.append((line_id, (last_x, last_y, event.x, event.y)))
        draw.line([last_x, last_y, event.x, event.y], fill=STROKE_COLOR, width=STROKE_WIDTH)
    last_x, last_y = event.x, event.y

def end_paint(event):
    global last_x, last_y, strokes, current_stroke, actions, redo_stack
    if erase_mode:
        end_erase(event)
        return
    last_x, last_y = None, None
    if current_stroke:
        strokes.append(current_stroke)
        actions.append(("draw", current_stroke))
        redo_stack.clear()  # limpiar pila de rehacer
    current_stroke = []

def undo(event=None):
    global strokes, actions, redo_stack, image, draw
    if not actions:
        return
    action, data = actions.pop()
    redo_stack.append((action, data))

    if action == "draw":
        if data in strokes:
            strokes.remove(data)
        for line_id, _ in data:
            canvas.delete(line_id)

    elif action == "erase":
        for stroke in data:
            strokes.append(stroke)
            for _, (x1, y1, x2, y2) in stroke:
                lid = canvas.create_line(x1, y1, x2, y2,
                                         fill=STROKE_COLOR, width=STROKE_WIDTH, capstyle=tk.ROUND, smooth=True)
                stroke[stroke.index((_, (x1, y1, x2, y2)))] = (lid, (x1, y1, x2, y2))

    redraw_image()

def redo(event=None):
    global strokes, actions, redo_stack
    if not redo_stack:
        return
    action, data = redo_stack.pop()
    actions.append((action, data))

    if action == "draw":
        strokes.append(data)
        for _, (x1, y1, x2, y2) in data:
            lid = canvas.create_line(x1, y1, x2, y2,
                                     fill=STROKE_COLOR, width=STROKE_WIDTH, capstyle=tk.ROUND, smooth=True)
            data[data.index((_, (x1, y1, x2, y2)))] = (lid, (x1, y1, x2, y2))

    elif action == "erase":
        for stroke in data:
            if stroke in strokes:
                for lid, _ in stroke:
                    canvas.delete(lid)
                strokes.remove(stroke)

    redraw_image()

def redraw_image():
    global image, draw
    image = Image.new("RGB", (canvas_width, canvas_height), BG_COLOR)
    draw = ImageDraw.Draw(image)
    for stroke in strokes:
        for _, (x1, y1, x2, y2) in stroke:
            draw.line([x1, y1, x2, y2], fill=STROKE_COLOR, width=STROKE_WIDTH)

def save_to_tmp(event=None):
    subprocess.run(["makoctl", "dismiss", "-a"])
    save_path = "/tmp/canvas-draw.png"

    # Si no se dibujo nada, salimos del script informado del error y sin guardar
    # nada en disco o en el portapapeles
    if not strokes:
        if not quiet:
            subprocess.run([
                "notify-send",
                "-i",
                "system-error",
                "Canvas",
                "No se dibuj√≥ nada"
            ])
        if os.path.exists(save_path):
            os.remove(save_path)
    # Si si hay dibujo lo guardamos en disco.
    else:
        gray = image.convert("L")
        bg_gray = int(int(BG_COLOR[1:3], 16) * 0.299 +
                      int(BG_COLOR[3:5], 16) * 0.587 +
                      int(BG_COLOR[5:7], 16) * 0.114)
        mask = gray.point(lambda p: 0 if p == bg_gray else 255)
        bbox = mask.getbbox()
        if bbox:
            cropped = image.crop(bbox)
        else:
            cropped = image
        cropped.save(save_path, "PNG")

    # Si corresponde, guardamos la imagen en el portapapeles
    if strokes and not willLatex:
        subprocess.run(["wl-copy", "-t", "image/png"], input=open(save_path, "rb").read(), check=True)
        if not quiet:
            subprocess.run([
                "notify-send",
                "-i",
                "com.github.maoschanz.drawing",
                "Canvas",
                "Imagen copiada al portapapeles"
            ])

    root.destroy()

##########
# Borrar #
##########

erase_current = []

def toggle_erase_mode(event=None):
    global erase_mode
    erase_mode = not erase_mode
    if erase_mode:
        canvas.config(cursor="crosshair")
        status_var.set("üóëÔ∏è Modo borrar")
    else:
        canvas.config(cursor="hand1")
        status_var.set("‚úèÔ∏è Modo dibujar")

def point_near_line(px, py, x1, y1, x2, y2, tol):
    dx, dy = x2 - x1, y2 - y1
    if dx == dy == 0:
        return (px - x1)**2 + (py - y1)**2 <= tol**2
    t = max(0, min(1, ((px - x1) * dx + (py - y1) * dy) / (dx*dx + dy*dy)))
    proj_x, proj_y = x1 + t * dx, y1 + t * dy
    dist2 = (proj_x - px)**2 + (proj_y - py)**2
    return dist2 <= tol**2

def start_erase(event):
    global erase_current
    erase_current = []

def erase(event):
    global strokes, erase_current
    for stroke in list(strokes):
        for _, (x1, y1, x2, y2) in stroke:
            if point_near_line(event.x, event.y, x1, y1, x2, y2, erase_radius):
                for lid, _ in stroke:
                    canvas.delete(lid)
                strokes.remove(stroke)
                erase_current.append(stroke)
                break
    redraw_image()

def end_erase(event):
    global erase_current, actions, redo_stack
    if erase_current:
        actions.append(("erase", erase_current))
        redo_stack.clear()
    erase_current = []

###########
# Tkinter #
###########

root = tk.Tk()
root.title(WINTITLE)
root.resizable(False, False)

status_var = tk.StringVar(value="‚úèÔ∏è Modo dibujar")
status_label = tk.Label(root, textvariable=status_var, bg=BG_COLOR, fg=STROKE_COLOR)
status_label.pack(side=tk.BOTTOM, fill=tk.X)

canvas = tk.Canvas(root, bg=BG_COLOR, width=canvas_width, height=canvas_height, cursor="hand1")
canvas.pack(fill=tk.BOTH, expand=True)

draw_grid()

canvas.bind("<Button-1>", start_paint)
canvas.bind("<B1-Motion>", paint)
canvas.bind("<ButtonRelease-1>", end_paint)

root.bind("<Control-z>", undo)
root.bind("<Control-Shift-KeyPress-Z>", redo)
root.bind("<Escape>", save_to_tmp)
root.bind("<KeyPress-d>", toggle_erase_mode)
root.bind("<KeyPress-D>", toggle_erase_mode)

root.focus_set()
root.mainloop()

#!/bin/bash

# Script para crear mirrors de una biblioteca de comics en un formato optimizado

# por aleister888 <pacoe1000@gmail.com>
# Licencia: GNU GPLv3

# Número máximo de codificaciones simultaneas
MAX_JOBS=$(nproc)
# Segundos de espera entre cada verificación
WAIT_TIME=$(echo "scale=4; 1/$(((MAX_JOBS + 1) / 2))" | bc)

BASE_EX_DIR="$HOME/.cache/comic_repack"

# Función para verificar que las dependencias están instaladas
check_command() {
	if ! command -v "$1" &>/dev/null; then
		echo "El comando $1 no se encontró. Por favor, instálalo usando:"
		echo
		echo "$2"
		exit 1
	fi
}

# Verificar que todas las dependencias están instaladas
check_command "unzip" "sudo /usr/bin/pacman -S unzip"
check_command "unrar" "sudo /usr/bin/pacman -S unrar"
check_command "mogrify" "sudo /usr/bin/pacman -S imagemagick"
check_command "zip" "sudo /usr/bin/pacman -S zip"

#::::::::::::::::::::::::::::::::::::::::::::::::::::::#
# Funciones
#::::::::::::::::::::::::::::::::::::::::::::::::::::::#

usage() {
	echo -e "Uso: $(basename "$0") [Directorio original] [Directorio copia]"
	echo -e "       -h: Mostrar este mensaje"
	exit
}

extract() {
	local FILE="$1"
	local OUT_DIR="$2"

	FILETYPE="$(file -b --mime-type "$(readlink -f "$FILE")")"
	case "$FILETYPE" in
	application/zip) # cbz
		mkdir -p "$OUT_DIR"
		unzip "$FILE" -d "$OUT_DIR"
		;;
	application/vnd.rar) # cbr
		mkdir -p "$OUT_DIR"
		unrar x "$FILE" "$OUT_DIR"
		;;
	*)
		return 1
		;;
	esac
}

image_process() {
	local DIR="$1"

	shopt -s nullglob

	# Archivos a borrar (marcas de agua, etc.)
	PATTERNS=("zWater")
	for FILE in "$DIR"/*; do
		for PAT in "${PATTERNS[@]}"; do
			if [[ "$FILE" == *"$PAT"* ]]; then
				rm "$FILE"
				break
			fi
		done
	done

	# Reducimos la calidad de las imágenes y las convertimos a jpg
	# para acelerar la apertura de los archivos

	MOGRIFY_OPTS="-resize 900x -strip -interlace none -quality 70"

	for JPG in "$DIR"/*.jpg; do
		# shellcheck disable=2086
		mogrify $MOGRIFY_OPTS "$JPG"
	done

	for PNG in "$DIR"/*.png; do
		# shellcheck disable=2086
		mogrify -format jpg $MOGRIFY_OPTS "$PNG"
		rm "$PNG"
	done
}

repack() {
	local FILE="$1"
	local OG_FILE="$OG_DIR/$FILE"
	local MIRROR_FILE="$MIRROR_DIR/${FILE%.*}.cbz"

	# shellcheck disable=SC2155
	local EX_DIR=$(mktemp -d "$BASE_EX_DIR"/XXXXXX)

	# Extraemos las imagenes en un directorio temporal
	extract "$OG_FILE" "$EX_DIR" || return 1

	# Procesamos las imagenes extraidas
	image_process "$EX_DIR"

	mkdir -p "$(dirname "$MIRROR_FILE")"

	# Archivamos sin compresión para acelerar la aptertura de los archivos
	zip -r -0 -j "$MIRROR_FILE" "$EX_DIR"/*

	rm -rf "$EX_DIR"
}

# Verificamos que el directorio original existe
[ ! -d "$1" ] && {
	echo "Error: El directorio original no existe."
	exit 1
}

OG_DIR="$1"
MIRROR_DIR="$2"

# Nos aseguramos que los directorios espejo y temporal existan
[ ! -d "$MIRROR_DIR" ] && mkdir -p "$MIRROR_DIR"
[ ! -d "$BASE_EX_DIR" ] && mkdir -p "$BASE_EX_DIR"

#::::::::::::::::::::::::::::::::::::::::::::::::::::::#
# Identificar archivos cbr/cbz
#::::::::::::::::::::::::::::::::::::::::::::::::::::::#

# Creamos un array con todos los elementos del directorio original
FILES=()

# Iteramos sobre cada archivo del directorio original, comprobamos si es un
# archivo cbr/cbz, y si lo es, lo añadimos al array que contiene los archivos
# a procesar (ruta relativa)

while IFS= read -r FILE; do
	FILETYPE="$(file -b --mime-type "$(readlink -f "$FILE")")"
	case "$FILETYPE" in
	application/zip)
		FILES+=("$(realpath --relative-to="$OG_DIR" "$FILE")")
		;;
	application/vnd.rar) # cbr
		FILES+=("$(realpath --relative-to="$OG_DIR" "$FILE")")
		;;
	esac
done < <(find "$OG_DIR" -type f)

#::::::::::::::::::::::::::::::::::::::::::::::::::::::#
# Procesar archivos uno a uno
#::::::::::::::::::::::::::::::::::::::::::::::::::::::#

for FILE in "${FILES[@]}"; do
	# Solo se permiten $MAX_JOBS codificaciones simultáneamente
	while [ "$(jobs -rp | wc -l)" -ge "$MAX_JOBS" ]; do
		sleep "${WAIT_TIME}s"
	done

	# El archivo no esta en el directorio espejo
	if [ ! -e "$MIRROR_DIR/${FILE%.*}.cbz" ]; then
		repack "$FILE" &
	fi
done

wait

#::::::::::::::::::::::::::::::::::::::::::::::::::::::#
# Borramos los archivos que ya no estan en el original
#::::::::::::::::::::::::::::::::::::::::::::::::::::::#

# Iteramos sobre cada archivo del directorio espejo. Si no existe el archivo de
# en el directorio original, borramos la copia del directorio espejo

while IFS= read -r MIRROR_FILE; do
	FILE="$(realpath --relative-to="$MIRROR_DIR" "$MIRROR_FILE")"
	BASENAME="${FILE%.*}"

	MATCHES=$(
		find "$OG_DIR" -type f -wholename "$OG_DIR/$BASENAME*"
	)

	[ -z "$MATCHES" ] && rm "$MIRROR_FILE"
done < <(find "$MIRROR_DIR" -type f)

# Borramos los directorios vacíos que pueden haber quedado
find "$MIRROR_DIR" \
	-type d -empty -not -path "*/.stfolder" -delete -print 2>/dev/null

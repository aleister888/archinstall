#!/bin/bash
# shellcheck disable=SC1091,SC2155

# Crear mirrors de una biblioteca de comics en un formato optimizado

source "$HOME/.dotfiles/assets/shell/profile"
source "$HOME/.dotfiles/assets/shell/shell-utils"

# Número máximo de codificaciones simultaneas
MAX_JOBS=$(($(nproc) / 4))
# Segundos de espera entre cada codificación
WAIT_TIME=$(echo "scale=4; 1/$(((MAX_JOBS + 1) / 2))" | bc)

BASE_EX_DIR="$(get_cache_tmp comic_repack)"

init_log comic_repack >/dev/null

check_command "unzip"
check_command "unrar"
check_command "mogrify"
check_command "zip"

#-------------------------------------------------------------------------------

extract() {
	local FILE="$1" OUT_DIR="$2"

	FILETYPE="$(file -b --mime-type "$(readlink -f "$FILE")")"
	case "$FILETYPE" in
	application/zip) # cbz
		mkdir -p "$OUT_DIR"
		unzip "$FILE" -d "$OUT_DIR"
		;;
	application/vnd.rar) # cbr
		mkdir -p "$OUT_DIR"
		unrar x "$FILE" "$OUT_DIR"
		;;
	*)
		return 1
		;;
	esac
}

images_process() {
	local DIR="$1"

	shopt -s nullglob

	# Archivos a borrar (marcas de agua, etc.)
	PATTERNS=("zWater")
	for FILE in "$DIR"/*; do
		for PAT in "${PATTERNS[@]}"; do
			if [[ "$FILE" == *"$PAT"* ]]; then
				rm "$FILE"
				break
			fi
		done
	done

	# Reducimos la calidad de las imágenes y las convertimos a jpg
	# para acelerar la apertura de los archivos

	MOGRIFY_OPTS="-resize 900x -strip -interlace none -quality 70"

	for JPG in "$DIR"/*.jpg; do
		# shellcheck disable=2086
		mogrify $MOGRIFY_OPTS "$JPG"
	done

	for PNG in "$DIR"/*.png; do
		# shellcheck disable=2086
		mogrify -format jpg $MOGRIFY_OPTS "$PNG"
		rm "$PNG"
	done
}

repack() {
	local FILE="$1"
	local OG_FILE="$OG_DIR/$FILE"
	local MIRROR_FILE="$MIRROR_DIR/${FILE%.*}.cbz"
	local EX_DIR=$(mktemp -d "$BASE_EX_DIR"/XXXXXX)

	# Extraemos las imagenes en un directorio temporal y las procesamos
	extract "$OG_FILE" "$EX_DIR" || return 1
	images_process "$EX_DIR"

	mkdir -p "$(dirname "$MIRROR_FILE")"
	zip -r -0 -j "$MIRROR_FILE" "$EX_DIR"/*
	rm -rf "$EX_DIR"
}

[ ! -d "$1" ] && {
	log "El directorio original no existe."
	exit 1
}

OG_DIR="$1"
MIRROR_DIR="$2"

ensure_dir "$MIRROR_DIR" >/dev/null

# Identificar archivos cbr/cbz
#-------------------------------------------------------------------------------

FILES=()

# Iteramos sobre cada archivo del directorio original, comprobamos si es un
# archivo cbr/cbz, y si lo es, lo añadimos al array que contiene los archivos
# a procesar (ruta relativa)

while IFS= read -r FILE; do
	FILETYPE="$(file -b --mime-type "$(readlink -f "$FILE")")"
	case "$FILETYPE" in
	application/zip)
		FILES+=("$(realpath --relative-to="$OG_DIR" "$FILE")")
		;;
	application/vnd.rar) # cbr
		FILES+=("$(realpath --relative-to="$OG_DIR" "$FILE")")
		;;
	esac
done < <(find "$OG_DIR" -type f)

# Procesar archivos uno a uno
#-------------------------------------------------------------------------------

for FILE in "${FILES[@]}"; do
	while [ "$(jobs -rp | wc -l)" -ge "$MAX_JOBS" ]; do
		sleep "${WAIT_TIME}s"
	done

	[ ! -e "$MIRROR_DIR/${FILE%.*}.cbz" ] && { repack "$FILE" & }
done

wait

# Borramos los archivos que ya no estan en el original
#-------------------------------------------------------------------------------

# Iteramos sobre cada archivo del directorio espejo. Si no existe el archivo de
# en el directorio original, borramos la copia del directorio espejo

while IFS= read -r MIRROR_FILE; do
	FILE="$(realpath --relative-to="$MIRROR_DIR" "$MIRROR_FILE")"
	BASENAME="${FILE%.*}"

	MATCHES=$(
		find "$OG_DIR" -type f -wholename "$OG_DIR/$BASENAME*"
	)

	[ -z "$MATCHES" ] && rm "$MIRROR_FILE"
done < <(find "$MIRROR_DIR" -type f)

# Borramos los directorios vacíos que pueden haber quedado
find "$MIRROR_DIR" \
	-type d -empty -not -path "*/.stfolder" -delete -print 2>/dev/null

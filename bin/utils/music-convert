#!/bin/bash
# shellcheck disable=SC2155

# Script para crear mirrors en formato mp3/m4a de una biblioteca de música.

# por aleister888 <pacoe1000@gmail.com>
# Licencia: GNU GPLv3

# TODO: Si el archivo original esta ya en el formato deseado, lo copiamos en
#       vez de recodificarlo

# Número maximo de codificaciones simultaneas
MAX_JOBS=$(nproc)
# Segundos de espera entre cada verificación
WAIT_TIME=$(echo "scale=4; 1/$(((MAX_JOBS + 1) / 2))" | bc)

# Función para verificar que las dependencias estan instaladas
check_command() {
	if ! command -v "$1" &>/dev/null; then
		echo "El comando $1 no se encontró. Por favor, instálalo usando:"
		echo
		echo "$2"
		exit 1
	fi
}

# Verificar que todas las dependencias están instaladas
check_command "atomicparsley" "sudo /usr/bin/pacman -S atomicparsley"
check_command "ffmpeg" "sudo /usr/bin/pacman -S ffmpeg"
check_command "glyrc" "sudo /usr/bin/pacman -S glyrc"
check_command "eyeD3" "yay -S python-eyed3"

#::::::::::::::::::::::::::::::::::::::::::::::::::::::#
# Funciones
#::::::::::::::::::::::::::::::::::::::::::::::::::::::#

usage() {
	echo -e "Uso: $(basename "$0") [Flags] [Directorio original] [Directorio copia]"
	echo -e "     Flags:"
	echo -e "       -h: Mostrar este mensaje"
	echo -e "       -mp3: Conviertir a mp3 (Default)"
	echo -e "       -m4a: Conviertir a m4a"
	exit
}

compare() {
	local OG_FILE="$OG_DIR/$FILE"
	local MIRROR_FILE="$MIRROR_DIR/${FILE%.*}.$EXTENSION"

	local OG_TIME=$(date -r "$OG_FILE" +%Y%m%d%H%M%S 2>/dev/null)
	local MIRROR_TIME=$(date -r "$MIRROR_FILE" +%Y%m%d%H%M%S 2>/dev/null)

	# El original es mas nuevo -> Se necesita recodificar
	if [ "$OG_TIME" -gt "$MIRROR_TIME" ]; then
		return 0
	# El original es más antiguo
	else
		return 1
	fi
}

convert_file() {
	local FILE="$1"
	local OG_FILE="$OG_DIR/$FILE"
	local MIRROR_FILE="$MIRROR_DIR/${FILE%.*}.$EXTENSION"
	[ "$EXTENSION" = "mp3" ] && local CODEC="libmp3lame"
	[ "$EXTENSION" = "m4a" ] && local CODEC="aac"

	2UTF8() {
		iconv -f UTF-8 -t ASCII//TRANSLIT
	}

	# Obtener los metadatos y borrar/sustituir caracteres conflictivos
	get_meta() {
		awk -F "=" "tolower(\$0) ~ /^$1=/ {print \$2}" | 2UTF8
	}

	# Creamos el directorio del archivo destino
	mkdir -p "$(dirname "$MIRROR_FILE")"

	echo "Convirtiendo $(basename "$FILE") a $EXTENSION"

	# Extraemos los datos de nuestro archivo original
	local MDATA=$(ffmpeg -nostdin -i "$OG_FILE" -f ffmetadata - 2>/dev/null)
	local TITLE=$(echo "$MDATA" | get_meta title)
	local ARTIST=$(echo "$MDATA" | get_meta artist)
	local ALBUM_ARTIST=$(echo "$MDATA" | get_meta album_artist)
	local ALBUM=$(echo "$MDATA" | get_meta album)
	local TRACK=$(echo "$MDATA" | get_meta track | sed "s|/.*||")
	local DISC=$(echo "$MDATA" | get_meta disc | sed "s|/.*||")
	local DATE=$(echo "$MDATA" | get_meta date | sed "s|-.*||")
	[ -z "$DISC" ] && DISC=1
	[ -z "$TRACK" ] && TRACK=1
	[ -z "$DISC" ] && DISC=1

	# Convertir el archivo
	ffmpeg -nostdin -i "$OG_FILE" \
		-codec:a "$CODEC" \
		-field_order tt -r 1 \
		-vcodec mjpeg \
		-vf scale=480:480 \
		-metadata:s:v title="Album cover" \
		-metadata:s:v comment="Cover (front)" \
		-map_metadata -1 \
		-metadata artist="$ARTIST" \
		-metadata title="$TITLE" \
		-metadata album="$ALBUM" \
		-metadata album_artist="$ALBUM_ARTIST" \
		-metadata date="$DATE" \
		-metadata track="$TRACK" \
		-metadata disc="$DISC" \
		"$MIRROR_FILE" >/dev/null 2>&1

	if [ "$LYRICS" = true ]; then
		# Archivo temporal para guardar las letras
		local TMPDIR="/tmp/$(basename "$0")"
		local TMPLYRICS="$TMPDIR/$RANDOM$RANDOM.txt"

		mkdir -p "$TMPDIR"

		# Antes de intentar obtener las letras de internet, comprobamos
		# si el archivo original no tiene ya la letra
		local LOCAL_LYRICS=$(
			ffprobe -v error -show_entries format_tags=LYRICS \
				-of default=noprint_wrappers=1:nokey=1 "$OG_FILE"
		)

		# Si la letra se extrajo correctamente la guardamos
		if [[ -n "$LOCAL_LYRICS" ]]; then
			echo "$LOCAL_LYRICS" | tee "$TMPLYRICS"
		else
			# Si el archivo original no tenía letra, entoncces la extraemos de internet
			glyrc lyrics -8 \
				-a "$ARTIST" \
				-t "$TITLE" \
				-b "$ALBUM" \
				-l "en" \
				--from "metallum;vagalume;elyrics" \
				--write "$TMPLYRICS" >/dev/null 2>&1
		fi

		if [ -f "$TMPLYRICS" ]; then
			# Aveces si la canción tiene el mismo nombre que el álbum glyrc puede
			# devolver el tracklist en vez de la letra de la canción
			COUNT_NUMS=$(grep -cP '^[[:space:]]*[0-9]+\.' "$TMPLYRICS")
			[ "$COUNT_NUMS" -ge 3 ] && {
				rm -f "$TMPLYRICS"
				return
			}

			[ $EXTENSION = "mp3" ] &&
				eyeD3 --add-lyrics="$TMPLYRICS" "$MIRROR_FILE" >/dev/null 2>&1
			[ $EXTENSION = "m4a" ] &&
				atomicparsley "$MIRROR_FILE" \
					--lyrics "$(cat "$TMPLYRICS" | 2UTF8)" --overWrite >/dev/null 2>&1
			rm -f "$TMPLYRICS"
		fi
	fi
}

#::::::::::::::::::::::::::::::::::::::::::::::::::::::#
# Procesar argumentos
#::::::::::::::::::::::::::::::::::::::::::::::::::::::#

LYRICS=false
EXTENSION="mp3"

# Procesamos los flags
while [[ $# -gt 0 ]]; do
	case "$1" in
	-mp3)
		EXTENSION="mp3"
		shift
		;;
	-m4a)
		EXTENSION="m4a"
		shift
		;;
	-l)
		LYRICS=true
		shift
		;;
	-h | --help) usage ;;
	*) break ;;
	esac
done

# Verificamos que el directorio original existe
[ ! -d "$1" ] && {
	echo "Error: El directorio original no existe."
	exit 1
}

OG_DIR="$1"
MIRROR_DIR="$2"

# Nos aseguramos que el directorio espejo exista
[ ! -d "$MIRROR_DIR" ] && mkdir -p "$MIRROR_DIR"

#::::::::::::::::::::::::::::::::::::::::::::::::::::::#
# Identificar archivos de audio
#::::::::::::::::::::::::::::::::::::::::::::::::::::::#

# Creamos un array con todos los elementos del directorio original
FILES=()

# Iteramos sobre cada archivo del directorio original
while IFS= read -r FILE; do
	# Comprobamos si es un archivo de audio
	[[ $(file --dereference --brief --mime-type -- "$FILE") == audio/* ]] &&
		# Si es un archivo de audio lo añadimos al array con su ruta relativa
		FILES+=("$(realpath --relative-to="$OG_DIR" "$FILE")")
done < <(find "$OG_DIR" -type f)

#::::::::::::::::::::::::::::::::::::::::::::::::::::::#
# Procesar archivos uno a uno
#::::::::::::::::::::::::::::::::::::::::::::::::::::::#

for FILE in "${FILES[@]}"; do
	# Solo se permiten $MAX_JOBS codificaciones simultáneamente
	while [ "$(jobs -rp | wc -l)" -ge "$MAX_JOBS" ]; do
		sleep "${WAIT_TIME}s"
	done

	# 1. El archivo no esta en el directorio espejo
	if [ ! -e "$MIRROR_DIR/${FILE%.*}.$EXTENSION" ]; then
		convert_file "$FILE" &
		continue
	fi

	# 2. El archivo esta en el directorio espejo pero ha cambiado desde
	#    que se convirtió a mp3/m4a
	if compare "$FILE"; then
		convert_file "$FILE" &
	fi
done

wait

#::::::::::::::::::::::::::::::::::::::::::::::::::::::#
# Borramos los archivos que ya no estan en el original
#::::::::::::::::::::::::::::::::::::::::::::::::::::::#

# Iteramos sobre cada archivo del directorio espejo
while IFS= read -r MIRROR_FILE; do
	FILE="$(realpath --relative-to="$MIRROR_DIR" "$MIRROR_FILE")"
	BASENAME="${FILE%.*}"

	MATCHES=$(
		find "$OG_DIR" -type f -wholename "$OG_DIR/$BASENAME*" |
			grep -vP ".*(lrc|txt)"
	)

	# Si no existe el archivo de audio en el directorio original, borramos
	# la copia del directorio espejo
	[ -z "$MATCHES" ] && rm "$MIRROR_FILE"
done < <(find "$MIRROR_DIR" -type f)

# Borramos los directorios vacíos que pueden haber quedado
find "$MIRROR_DIR" \
	-type d -empty -not -path "*/.stfolder" -delete -print 2>/dev/null

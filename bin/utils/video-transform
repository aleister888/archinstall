#!/bin/bash
# shellcheck disable=SC2086,SC2012,SC2116,SC1091

# Recodifíca videos a h.264 con la opción de rotarlos

source "$HOME/.dotfiles/assets/shell/shell-utils"

MAX_RES="${MAX_RES:=1440}"

IN_FILE=$1
FILENAME="${IN_FILE%.*}"
BASE_NAME="$(basename "$FILENAME")"
EXTENSION="${IN_FILE##*.}"
OUT_FILE=${2:-$(get_tmp video_transform)/${BASE_NAME}_recoded.${EXTENSION}}
ROTATION=$3
TERM_OUTPUT=$(mktemp)

declare -A ERROR_MAP=(
	["No usable encoding entrypoint"]="VAAPI_UNSUPPORTED_PROFILE"
	["Function not implemented"]="VAAPI_NOT_IMPLEMENTED"
	["Could not open encoder"]="ENCODER_INIT_FAILED"
	["Invalid argument"]="INVALID_ARGUMENT"
)

detect_error() {
	local LOG="$1"
	local ERROR=false

	for pattern in "${!ERROR_MAP[@]}"; do
		if FILTER_ERR=$(grep "$pattern" <<<"$LOG"); then
			echo -e "${ERROR_MAP[$pattern]}"
			echo -e "$(echo "$FILTER_ERR" | grep -oP "\[.*\] \K.*")\n"
			ERROR=true
		fi
	done

	[ $ERROR == true ] && {
		rm -f "$OUT_FILE"
		exit 1
	}
}

[ ! -e "$IN_FILE" ] && exit 1
mkdir -p "$(dirname "$OUT_FILE")"

HEIGHT=$(
	ffprobe -v error -select_streams v:0 \
		-show_entries stream=height \
		-of default=nokey=1:noprint_wrappers=1 "$IN_FILE"
)

case "$ROTATION" in
90) ROTATE="transpose=1" ;;
180) ROTATE="transpose=1,transpose=1" ;;
270) ROTATE="transpose=2" ;;
*) ROTATE="" ;;
esac

HW_ACCEL="software"
if command -v nvidia-smi >/dev/null 2>&1; then
	HW_ACCEL="nvidia"
elif [ -d /dev/dri ] && VAAPI_RENDER=$(find /dev/dri/renderD* | head -n1); then
	HW_ACCEL="vaapi"
fi

# Los filtros de procesamiento transpose y scale solo funcionan en la CPU, para
# poder aplicarlos correctamente debemos ordenar los argumentos en este orden:
#
#     1. hwdownload  - descarga frames GPU -> CPU
#     2. format=nv12 - formato píxeles
#     3. filtros
#     4. hwupload    - frames CPU -> GPU

CPU_FILTERS=()
[ "$HEIGHT" -ge "$MAX_RES" ] && CPU_FILTERS+=("scale=-2:$MAX_RES")
[ -n "$ROTATE" ] && CPU_FILTERS+=("$ROTATE")

case "$HW_ACCEL" in
nvidia)
	VIDEO_CODEC=(-c:v h264_nvenc -preset p5 -cq 23)
	# el encoder acepta nv12 desde CPU
	if [ ${#CPU_FILTERS[@]} -gt 0 ]; then
		CPU_VF=$(IFS=, echo "${CPU_FILTERS[*]}")
		VF="$CPU_VF,format=nv12"
	else
		VF=""
	fi
	;;
vaapi)
	VIDEO_CODEC=(-c:v h264_vaapi -qp 23)
	if [ ${#CPU_FILTERS[@]} -gt 0 ]; then
		CPU_VF=$(IFS=, echo "${CPU_FILTERS[*]}")
		VF="hwdownload,format=nv12,$CPU_VF,format=nv12,hwupload"
	else
		VF=""
	fi
	;;
software)
	VIDEO_CODEC=(-c:v libx264 -preset medium -crf 23)
	CPU_VF=$(IFS=, echo "${CPU_FILTERS[*]}")
	;;
esac

FFMPEG_CMD=(-hide_banner -y -i "$IN_FILE")

[ "$HW_ACCEL" = "vaapi" ] &&
	FFMPEG_CMD=(-init_hw_device vaapi=va:"$VAAPI_RENDER" -hwaccel vaapi -hwaccel_output_format vaapi "${FFMPEG_CMD[@]}")

[ -n "$VF" ] && FFMPEG_CMD+=(-vf "$VF")
FFMPEG_CMD+=("${VIDEO_CODEC[@]}" -c:a copy "$OUT_FILE")

ffmpeg "${FFMPEG_CMD[@]}" 2>"$TERM_OUTPUT"
detect_error "$(cat "$TERM_OUTPUT")"

rm "$TERM_OUTPUT"
echo "Archivo guardado en $OUT_FILE"
